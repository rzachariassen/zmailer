<CHAPTER ID="ZREF-ROUTER"><?dbhtml filename="zref-router.html">
<TITLE><COMMAND>Router</> Reference</TITLE>

<PARA>
The <COMMAND>router</> daemon makes all decisions affecting 
the processing of messages in ZMailer.
</PARA>

<PARA>
A mail message is submitted by placing it in a file in the
<FILENAME CLASS="DIRECTORY">$<VARNAME>POSTOFFICE</>/router/</> directory.
The  <COMMAND>router</> frequently scans this directory for new 
files and will lock and process them as it finds them. 
The result is a message control file that gets linked into 
the <FILENAME CLASS="DIRECTORY">$<VARNAME>POSTOFFICE</>/scheduler/</> and 
<FILENAME CLASS="DIRECTORY">$<VARNAME>POSTOFFICE</>/transport/</>
directories for use by the <COMMAND>scheduler</> in the next step
of message processing.
The original message file is then moved to the 
<FILENAME CLASS="DIRECTORY">$<VARNAME>POSTOFFICE</>/queue/</>
directory. 
</PARA>

<PARA>
The <COMMAND>router</>'s behaviour is controlled by a configuration
file read at startup.
It is really a  <COMMAND>zmsh</>(1) script that uses facilities provided 
builtin to the <COMMAND>router</>. 
</PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>Usage:</TERM><LISTITEM>

<PARA>
Invoking router without any arguments will do nothing (except make it read
its configuration file and promptly exit).
The normal startup method is to run the <COMMAND>zmailer</>(1) script, as
in "<COMMAND>zmailer router</>".
This will start the <COMMAND>router</> as a daemon and kill the previous 
incarnation of the <COMMAND>router</>.
</PARA>

<PARA>
<CMDSYNOPSIS>
  <COMMAND>router</>
    <ARG>-diksSV</ARG>
    <ARG>-f configfile</ARG>
    <ARG>-n #routers</ARG>
    <ARG>-o zmsh-options</ARG>
    <ARG>-t traceflag</ARG>
    <ARG>-L logfile</ARG>
    <ARG>-P postoffice</ARG>
</CMDSYNOPSIS>
</PARA>

</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Parameters:</TERM><LISTITEM>
<PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>-d</></><LISTITEM><PARA>
Detach and run as a daemon. 
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-f <REPLACEABLE>configfile</></></TERM><LISTITEM><PARA>
Overrides the default configuration 
file <FILENAME>$<VARNAME>MAILSHARE</>/router.cf</>. 
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-i</></TERM><LISTITEM><PARA>
Run interactively, presenting a <COMMAND>zmsh</>  
session with the configuration file preloaded. 
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-k</></TERM><LISTITEM><PARA>
Kill the currently running router by 
sending it a <CONSTANT>SIGTERM</> signal. 
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-L <REPLACEABLE>logfile</></></TERM><LISTITEM><PARA>
Overrides the default  log file location 
<FILENAME>$<VARNAME>LOGDIR</>/router</>. 
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-n <REPLACEABLE>#routers</></></TERM><LISTITEM><PARA>
Starts the specified number of parallel router processes.
The default is a single router process. 
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-o <REPLACEABLE>zmsh-options</></></TERM><LISTITEM><PARA>
Sets the option string passed on the internal <COMMAND>zmsh</> invocation.
The default is <OPTION>-O</>. 
Note that the leading "-" is mandatory.
See <LINK LINKEND="zref-zmsh-options"><CITETITLE><COMMAND>zmsh</>(1)</CITETITLE>
</LINK> (at <XREF LINKEND="zref-zmsh-options">) for the available options. 
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-P <REPLACEABLE>postoffice</></></TERM><LISTITEM><PARA>
Specifies an alternate 
<FILENAME CLASS="DIRECTORY">$<VARNAME>POSTOFFICE</>/</> directory. 
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-S</></TERM><LISTITEM><PARA>
Can be used to turn off non-serious syslogging. 
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-s</></TERM><LISTITEM><PARA>
Turns stability-flag off and on. Without this
flag, the search of new jobs will be done with (sometimes) 
timeconsuming care of organizing the job files into time order. 
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-t <REPLACEABLE>traceflag</></></TERM><LISTITEM><PARA>
Sets trace options, one per <OPTION>-t</> switch, even before the configuration
file is loaded.
This is otherwise equivalent to the builtin <COMMAND>trace</> command.
The currently known options are:
<OPTION>assign, bind, compare, db, final, functions, matched, memory,
on, regexp, resolv, rewrite, router, and sequencer</OPTION>. 
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-V</></TERM><LISTITEM><PARA>
Print version message and run interactively. 
</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>
</PARA>

</LISTITEM></VARLISTENTRY>
</VARIABLELIST>

<PARA>
To restart a <COMMAND>router</> daemon: 
<SCREEN>
   <USERINPUT>router -dk</USERINPUT>
</SCREEN>
</PARA>

<PARA>
To test an address, start up an interactive session: 
<SCREEN>
  <USERINPUT>router -i</USERINPUT>
</SCREEN>
or if the ZMailer <COMMAND>sendmail</>(8) is installed: 
<SCREEN>
  <USERINPUT>sendmail -bt</USERINPUT>
</SCREEN>
</PARA>

<PARA>
Then just use the pre-defined functions.
</PARA>

<SECT1 ID="zmshref-script-language">
<TITLE>ZMSH Script Language</TITLE>

<PARA>
<COMMAND>zmsh</> is an implementation of the Bourne shell 
suitable for use with the ZMailer <COMMAND>router</>(8) as 
its configuration file language interpreter. It contains 
extensions that allow structured data (in the form of lists) 
to be manipulated.
</PARA>

<PARA> 
The shell supports three basic kinds of functions: Unix 
commands, user-defined functions, and builtin commands. 
The latter comes in two variations: normal functions which 
take string arguments and return a status code (much as an 
embedded Unix command would work), and list-manipulation 
functions which understand list arguments and can return 
list arguments. The defined functions can take any form 
of argument and return any form of value (a status code, 
a string, or a list).
</PARA>

<PARA>
Shell operations (pipes, backquote evaluation and substitution) 
will work between combinations of builtin functions, 
defined functions, and Unix commands.
</PARA>

<PARA>
The shell precompiles its input to a (possibly optimized) byte-code form,
which is then interpreted as required.
This means that the original form of the input is not kept around
<EMPHASIS>in-core</> for future reference.
If the input is an included file, the shell will try to save the byte-code 
form in a <FILENAME>.fc</> file associated with the input file. 
For example, if input is from <FILENAME>file.cf</>, the shell will try to
create <FILENAME>fc/file.fc</> and then <FILENAME>file.fc</>. 
These files will in turn be searched for and loaded (after a consistency
check) whenever a <FILENAME>.cf</> file is included.
</PARA>

<PARA>
The effects of input and output redirections are predicted 
prior to the execution of a command and its I/O setup.
</PARA>

<SECT2 ID="zref-zmsh-usage">
<TITLE>ZMSH Usage:</TITLE>

<PARA>

<CMDSYNOPSIS>
  <COMMAND>zmsh</COMMAND>
    <ARG><OPTION>-CILOPRSYaefhinstuvx</></ARG>
    <ARG><OPTION>-c</> <REPLACEABLE>command</></ARG>
    <ARG><REPLACEABLE>script ...</></ARG>
</CMDSYNOPSIS>
</PARA>
</SECT2>

<SECT2  ID="zref-zmsh-options">
<TITLE>ZMSH Parameters:</TITLE>
<PARA>

<VARIABLELIST>

<VARLISTENTRY><TERM><OPTION>-c command</OPTION></TERM><LISTITEM><PARA>

Run the given argument as a shell 
command script. 

</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-a</OPTION></TERM><LISTITEM><PARA>

Automatically export new or changed shell 
variables.  

</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-e</OPTION></TERM><LISTITEM><PARA>

Exit on non-zero status return of any command. 

</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-f</OPTION></TERM><LISTITEM><PARA>

Disables filename generation. 

</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-h</OPTION></TERM><LISTITEM><PARA>

Hash and cache the location of Unix commands. 
The option is set by default. 

</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-i</OPTION></TERM><LISTITEM><PARA>

This shell is interactive, meaning prompts 
are printed when ready for more input, <LITERAL>SIGTERM</> signal 
is ignored, and the shell does not exit easily. This flag is 
automatically set if <LITERAL>stdin</> and <LITERAL>stderr</> are 
both attached to a <FILENAME>/dev/tty</>.

</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-n</OPTION></TERM><LISTITEM><PARA>

Read commands but do not execute them. 

</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-s</OPTION></TERM><LISTITEM><PARA>

Read commands from <LITERAL>stdin</>.
If there are non-option arguments to the shell, the first of
these will be interpreted as a shell script to open on <LITERAL>stdin</>,
and the rest as arguments to the script. 

</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-t</OPTION></TERM><LISTITEM><PARA>

Exit after running one command. 

</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-u</OPTION></TERM><LISTITEM><PARA>

Unset variables produce an error on 
substitution. 

</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-v</OPTION></TERM><LISTITEM><PARA>

Print shell input as it is read. 

</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-x</OPTION></TERM><LISTITEM><PARA>

Print commands as they are executed. 

</PARA></LISTITEM></VARLISTENTRY>

</VARIABLELIST></PARA>
</SECT2>

<SECT2   ID="zref-zmsh-debug-options">
<TITLE>ZMSH Debug options:</TITLE

<PARA>
<VARIABLELIST>

<VARLISTENTRY><TERM><OPTION>-C</></TERM><LISTITEM><PARA>

Print code generation output onto <LITERAL>stdout</>.
If this option is doubled, the non-optimized code is printed out instead.

</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-I</></TERM><LISTITEM><PARA>

Print runtime interpreter activity onto <FILENAME>/dev/tty</>.

</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-L</></TERM><LISTITEM><PARA>

Print lexer output onto <LITERAL>stdout</>. 

</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-O</></TERM><LISTITEM><PARA>

Optimize the compiled script.
If this option is doubled, the optimized code is also printed out. 

</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-P</></TERM><LISTITEM><PARA>

Print parser output (S/SL trace output) onto <LITERAL>stdout</>. 

</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-R</></TERM><LISTITEM><PARA>

Print I/O actions onto <FILENAME>/dev/tty</>.

</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-S</></TERM><LISTITEM><PARA>

Print scanner output (token assembly) onto <LITERAL>stdout</>.

</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>-Y</></TERM><LISTITEM><PARA>

Open <FILENAME>/dev/tty</> for internal debugging use. 

</PARA></LISTITEM></VARLISTENTRY>

</VARIABLELIST>
</PARA>

</SECT2>
</SECT1>


<SECT1 ID="zmshref-cfg-script-writing-rules">
<TITLE>Configuration Script Writing Rules</TITLE>

<SCREEN>
Text to be inserted here.
</SCREEN>

</SECT1>


<SECT1 ID=zmshref-script-security-issues>
<TITLE>Script Security Issues</TITLE>

<SCREEN>
Text to be inserted here.
</SCREEN>

</SECT1>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<SECT1 ID=zmshref-script-wellknown-functions>
<TITLE>Router Script Well Known Entrypoints</TITLE>

<PARA>
This section describes the <COMMAND>router</> internal functions
used as entrypoints by various uses inside and outside the <COMMAND>router</>
program.
</PARA>

<SECT2 ID=zmshref.wke.process><TITLE>The <FUNCTION>process()</> function</>

<PARA>
FIXME! WRITEME!
</PARA>
</SECT2>

<SECT2 ID=zmshref.wke.router><TITLE>The <FUNCTION>router()</> function</>

<PARA>
FIXME! WRITEME!
</PARA>
</SECT2>

<SECT2 ID=zmshref.wke.crossbar><TITLE>The <FUNCTION>crossbar()</> function</>

<PARA>
FIXME! WRITEME!
</PARA>
</SECT2>

<SECT2 ID=zmshref.wke.server><TITLE>The <FUNCTION>server()</> function</>

<PARA>
FIXME! WRITEME!
</PARA>
</SECT2>


</SECT1>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<SECT1 ID=zmshref-script-internal-functions>
<TITLE>Script Language Internal Functions</TITLE>

<PARA>
This section describes the <COMMAND>router</> internal functions.
</PARA>

<PARA>
FIXME! FIXME! some internal functions are missing from this listing!
</PARA>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.doublecolon">
<TITLE>"<FUNCTION>:</>" (doublecolon)</TITLE>

<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>:</> 
    <ARG CHOICE=PLAIN>&lt;SPC&gt;
      <REPLACEABLE>anything else forming a command pipeline</></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Description:</><LISTITEM><PARA>

none

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</><LISTITEM><PARA>

0

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</><LISTITEM><PARA>

none

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</><LISTITEM><PARA>

none

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>
</SECT2>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.include">
<TITLE>"<FUNCTION>.</>", "<FUNCTION>include</>"</TITLE>

<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>.</>
    <ARG CHOICE=PLAIN><REPLACEABLE>scriptfilename</></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Alternate syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>include</>
    <ARG CHOICE=PLAIN><REPLACEABLE>scriptfilename</></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

Exit status of script evaluation, or specifically:

<VARIABLELIST>
<VARLISTENTRY><TERM>1</TERM><LISTITEM><PARA>

File not found, or not fstat:able.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>2</TERM><LISTITEM><PARA>

Internal loadeval() didn't yield same result as fstat:ed file size is.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>64</TERM><LISTITEM><PARA>

Usage: Not exactly one parameter, or it is a void string.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This puts the running script to read more script from given filename.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.test">
<TITLE>"<FUNCTION>[</>", "<FUNCTION>test</>"</TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>[</>
    <ARG CHOICE=PLAIN><REPLACEABLE>test parameters</> ]</ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Alternate syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>test</>
    <ARG CHOICE=PLAIN><REPLACEABLE>test parameters</></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM> 1 </TERM><LISTITEM><PARA>

True.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM> 0 </TERM><LISTITEM><PARA>

False.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM> -1 </TERM><LISTITEM><PARA>

Error.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

<ITEMIZEDLIST>
<LISTITEM><PARA> File testing unary prefix functions:
<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>-b file</OPTION></TERM><LISTITEM><PARA>

True if file exists and is block special.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION> -c file</OPTION></TERM><LISTITEM><PARA>

True if file exists and is character special.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-d file</OPTION></TERM><LISTITEM><PARA>

True if file exists and is a directory.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-f file</OPTION></TERM><LISTITEM><PARA>

True if file exists and is a regular file.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-g file</OPTION></TERM><LISTITEM><PARA>

True if file exists and is set-group-id.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-k file</OPTION></TERM><LISTITEM><PARA>

True if file has its "sticky" bit set.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-p file</OPTION></TERM><LISTITEM><PARA>

True if file exists and is a named pipe.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-r file</OPTION></TERM><LISTITEM><PARA>

True if file exists and is readable.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-s file</OPTION></TERM><LISTITEM><PARA>

True if file exists and has a size greater than zero.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-t [fd]</OPTION></TERM><LISTITEM><PARA>

True if <OPTION>fd</> is opened on a terminal. 
If <OPTION>fd</> is omitted, it defaults to 1 (standard output).

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-u file</OPTION></TERM><LISTITEM><PARA>

True if file exists and its set-user-id bit is set.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-w file</OPTION></TERM><LISTITEM><PARA>

True if file exists and is writable.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-x file</OPTION></TERM><LISTITEM><PARA>

True if file exists and is executable.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>
</PARA></LISTITEM>

<LISTITEM><PARA> String testing binary functions:
<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>str1 = str2</OPTION></TERM><LISTITEM><PARA>

True if the strings are equal.

</PARA><PARA>
The "str1" must not begin with a hyphen "-" character!
(Actually they must not be any of the magic prefix-, or infix
 keyword operators, nor "(", "!", or ")". )

</PARA><PARA>
Suggested test setup:
<SCREEN>
  [ "x$varname" = "xliteral" ] ...
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>str1 != str2</OPTION></TERM><LISTITEM><PARA>

True if the strings are not equal.

</PARA><PARA>
The "str1" must not begin with a hyphen "-" character!
(Actually they must not be any of the magic prefix-, or infix
 keyword operators, nor "(", "!", or ")". )

</PARA><PARA>
Suggested test setup:
<SCREEN>
  [ "x$varname" != "xliteral" ] ...
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>
</PARA></LISTITEM>

<LISTITEM><PARA> Integer value testing binary functions:
<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>iexpr -eq iexpr</OPTION></TERM><LISTITEM><PARA>

True if integer values are equal.

</PARA><PARA>
The iexpr intermediate products are strings for the purposes of this
scanners input, but then they are internally treated as system local
"integer" datatype.

</PARA><PARA>
The <EMPHASIS>second</> iexpr can be a pair of: "-l string-expr"
which is evaluated as <EMPHASIS>length</> of that string-expr.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>iexpr -ne iexpr</OPTION></TERM><LISTITEM><PARA>

True if integer values are not equal.

</PARA><PARA>
The <EMPHASIS>second</> iexpr can be a pair of: "-l string-expr"
which is evaluated as <EMPHASIS>length</> of that string-expr.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>iexpr -gt iexpr</OPTION></TERM><LISTITEM><PARA>

True if integer value1 is greater than integer value2.

</PARA><PARA>
The <EMPHASIS>second</> iexpr can be a pair of: "-l string-expr"
which is evaluated as <EMPHASIS>length</> of that string-expr.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>iexpr -ge iexpr</OPTION></TERM><LISTITEM><PARA>

True if integer value1 is greater or equal than integer value2.

</PARA><PARA>
The <EMPHASIS>second</> iexpr can be a pair of: "-l string-expr"
which is evaluated as <EMPHASIS>length</> of that string-expr.


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>iexpr -lt iexpr</OPTION></TERM><LISTITEM><PARA>

True if integer value1 is less than integer value2.

</PARA><PARA>
The <EMPHASIS>second</> iexpr can be a pair of: "-l string-expr"
which is evaluated as <EMPHASIS>length</> of that string-expr.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>iexpr -le iexpr</OPTION></TERM><LISTITEM><PARA>

True if integer value1 is less or equal than integer value2.

</PARA><PARA>
The <EMPHASIS>second</> iexpr can be a pair of: "-l string-expr"
which is evaluated as <EMPHASIS>length</> of that string-expr.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>
</PARA></LISTITEM>

<LISTITEM><PARA> File comparison binary functions:
<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>file1 -nt file2</OPTION></TERM><LISTITEM><PARA>

True if file1's mtime is newer than file2's.

</PARA><PARA>

Filenames are best to be either absolute paths (begins with "/"),
or dot-relative (begins with "./" pair).  Unqualified names
are hazardous, e.g. "-file-name-".

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>file1 -ot file2</OPTION></TERM><LISTITEM><PARA>

True if file1's mtime is older than file2's.
(See comment above.)


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>file1 -ef file2</OPTION></TERM><LISTITEM><PARA>

True if both files have same inode, and device.
(See comment above.)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>
</PARA></LISTITEM>

<LISTITEM><PARA> Logical functions:
<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>! expr</OPTION></TERM><LISTITEM><PARA>

Unary NOT

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>expr -a expr</OPTION></TERM><LISTITEM><PARA>

Binary AND

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>expr -o expr</OPTION></TERM><LISTITEM><PARA>

Binary OR

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>( expr )</OPTION></TERM><LISTITEM><PARA>

Parenthesis

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>
</PARA></LISTITEM>
</ITEMIZEDLIST>



</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This is basically the shell "<FUNCTION>[</>" a.k.a. 
"<FUNCTION>test</>" program.

</PARA><PARA>

Do note that unlike more usual bourne-shells, this <EMPHASIS>does not</>
short-circuit logical evaluations, e.g. falseness of the left side of an AND
does not eliminate evaluation of the right side!

</PARA><PARA>

Usual "<FUNCTION>test</>" precautions with things like
parameter data prefixing with some character so that
it will not become treated as one of the control options.
<SCREEN>
Not:
  [ "$(funcname ...)" ]
  [ "$varname" = "value" ]

Ok:
  [ "z$(funcname ...)" ]
  [ "z$varname" = "zvalue" ]
</SCREEN>


</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.attributes">
<TITLE><FUNCTION>attributes</></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>attributes</>
    <ARG CHOICE=PLAIN><REPLACEABLE>object-reference</></>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

The property list symbol (4th) component 
of an address quad.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

none

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.basename">
<TITLE><FUNCTION>basename</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>basename</>
    <ARG CHOICE=PLAIN><REPLACEABLE>pathname</></ARG>
    <ARG><REPLACEABLE>suffix</></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

ok, result string to <LITERAL>stdout</>.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>1</TERM><LISTITEM><PARA>

Error.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

If a suffix is given and matches the filename, 
the suffix too is stripped from the filename.

</PARA><PARA>
There are no "-"-type options.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Prints the base filename of the pathname.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.break">
<TITLE><FUNCTION>break</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<SYNOPSIS>
while ...
do
   ...
   break
   ...
done

case ...
   ...
   break
   ...
esac
</SYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>1</TERM><LISTITEM><PARA>



</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.builtin">
<TITLE><FUNCTION>builtin</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<EMPHASIS ROLE="BOLD">NOT IMPLEMENTED!</>
<CMDSYNOPSIS>
  <COMMAND>builtin</>
    <ARG CHOICE=REQ><REPLACEABLE>builtin command name, and its params</></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>



</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

<EMPHASIS ROLE="BOLD">NOT IMPLEMENTED!</>
</PARA><PARA>

Ensures that named command is builtin within the scheduler,
and not a) external, b) script based.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!--
<SECT2 ID="zmshref.builtins">
<TITLE><FUNCTION>builtins</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

builtins

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

List builtin functions.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
 -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.car">
<TITLE><FUNCTION>car</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>car</>
    <ARG CHOICE=PLAIN><REPLACEABLE>object-reference</></ARG>
</CMDSYNOPSIS>
</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

Pointer to copied lisp-object of object-reference's
<FUNCTION>car</> operation.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This command is synonymous to the <LINK LINKEND="zmshref.channel">
<CITETITLE><FUNCTION>channel</></></LINK> (at
<XREF LINKEND="zmshref.channel">), and
<LINK LINKEND="zmshref.first"><CITETITLE><FUNCTION>first</></></LINK>
(at <XREF LINKEND="zmshref.first">) functions.

</PARA><PARA>
This version name is for die-hard LISP fans ;-)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.cat">
<TITLE><FUNCTION>cat</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>cat</>
    <ARG CHOICE=PLAIN REP=REPEAT><REPLACEABLE>filenames</></ARG>
</CMDSYNOPSIS>
</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

Output into <LITERAL>stdout</>, which can be piped ZMailer router script
internally to next receiver in a pipeline.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

The filenames to be "cat:ed" together need to be
regular files.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.cd">
<TITLE><FUNCTION>cd</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>cd</>
    <ARG><REPLACEABLE>directory</></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

<FUNCTION>cd</> successful.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>1</TERM><LISTITEM><PARA>

Error, can't find <LITERAL>$HOME</> environment variable.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>1</TERM><LISTITEM><PARA>

Error, internal <FUNCTION>chdir</>(2) call failed.
The <LITERAL>stderr</> gets an error string.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>64</TERM><LISTITEM><PARA>

Bad parameters (too many). (Usage.)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.cdr">
<TITLE><FUNCTION>cdr</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>cdr</>
    <ARG CHOICE=PLAIN><REPLACEABLE>object-reference</></>
</CMDSYNOPSIS>
</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

Pointer to copied lisp-object of object-reference's
<FUNCTION>cdr</> operation.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This command is synonymous to the <LINK LINKEND="zmshref.rest">
<CITETITLE><FUNCTION>rest</></></LINK> function
(at <XREF LINKEND="zmshref.rest">).

</PARA><PARA>
This version name is for die-hard LISP fans ;-)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.channel">
<TITLE><FUNCTION>channel</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>channel</>
    <ARG CHOICE=PLAIN><REPLACEABLE>object-reference</></ARG>
</CMDSYNOPSIS>
</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

The channel (1st) component of an address quad.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

The <LINK LINKEND="zmshref.car"><CITETITLE><FUNCTION>car</></></LINK>
(at <XREF LINKEND="zmshref.car">), and
<LINK LINKEND="zmshref.first"><CITETITLE><FUNCTION>first</></></LINK>
(at <XREF LINKEND="zmshref.first">)
functions are synonymous to this one.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.continue">
<TITLE><FUNCTION>continue</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>continue</>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>1</TERM><LISTITEM><PARA>



</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This affects control flow by returning it into
beginning of enclosing loop construction.

</PARA><PARA>

Usage examples:
<SCREEN>
  while ...
  do
     if ... something ...
     then
       ... something too ...
       continue
     fi
     ... more something ...
  done
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.daemon">
<TITLE><FUNCTION>daemon</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>daemon</>
</CMDSYNOPSIS>
</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>



</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Starts the <COMMAND>router</> running in daemon mode, 
scanning the <FILENAME CLASS=DIRECTORY>$<VARNAME>POSTOFFICE</>/router/</>
directory every few seconds for message files to process.
This function is invoked automatically by other code in
the <COMMAND>router</> program and has no other purpose.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.db">
<TITLE><FUNCTION>db</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
 <COMMAND>db</>
  <ARG CHOICE=PLAIN>add</>
  <ARG CHOICE=PLAIN><REPLACEABLE>database</></>
  <ARG CHOICE=PLAIN><REPLACEABLE>key</></>
  <ARG CHOICE=PLAIN><REPLACEABLE>value</></>
 <COMMAND>db</>
  <ARG CHOICE=PLAIN>flush</>
  <ARG CHOICE=PLAIN><REPLACEABLE>database</></>
 <COMMAND>db</>
  <ARG CHOICE=PLAIN>owner</>
  <ARG CHOICE=PLAIN><REPLACEABLE>database</></>
 <COMMAND>db</>
  <ARG CHOICE=PLAIN>print</>
  <ARG CHOICE=PLAIN><REPLACEABLE>database</></>
 <COMMAND>db</>
  <ARG CHOICE=PLAIN>remove</>
  <ARG CHOICE=PLAIN><REPLACEABLE>database</></>
  <ARG CHOICE=PLAIN><REPLACEABLE>key</></>
 <COMMAND>db</>
  <ARG CHOICE=PLAIN>count</>
  <ARG CHOICE=PLAIN><REPLACEABLE>database</></>
 <COMMAND>db</>
  <ARG CHOICE=PLAIN>toc</>
</CMDSYNOPSIS>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>



</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>1</TERM><LISTITEM><PARA>

Error.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>a[dd]</OPTION></TERM><LISTITEM><PARA>

Add a <PARAMETER>key,value</> entry to the database, if possible.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>f[lush]</OPTION></TERM><LISTITEM><PARA>

For "incore" database this means deletion of the content, but
for others this is IO buffer flush (in case of modifications.)

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>o[wner]</OPTION></TERM><LISTITEM><PARA>

Print the account name of the owner of the database, if possible.
This is usually determined by the files associated with the database.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>p[rint]</OPTION></TERM><LISTITEM><PARA>

Print all entries of the database, if possible. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>c[ount]</OPTION></TERM><LISTITEM><PARA>

Iterate thru the database and count entries in there.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>r[emove]</OPTION></TERM><LISTITEM><PARA>

Remove a <PARAMETER>key</> entry from the database, if possible.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>t[oc]</OPTION></TERM><LISTITEM><PARA>

Print a table of defined relations and their associated information.
This table has five columns, in order:
<ITEMIZEDLIST>
 <LISTITEM><PARA>the name of the relation</></>
 <LISTITEM><PARA>its type and subtype</></>
 <LISTITEM><PARA>cache entries and maximum cache size</></>
 <LISTITEM><PARA>flags</></>
 <LISTITEM><PARA>and associated files</></>
</ITEMIZEDLIST>
See the <FUNCTION>relation</> function for more information.
(<XREF LINKEND="zmshref.relation">)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

<INFORMALTABLE FRAME=ALL ID=tbl-zref-router-db-type-specific-notes>
<TGROUP COLS=7 ALIGN=LEFT COLSEP=1 ROWSEP=1>
<COLSPEC COLNAME=C1-DBTYPE-NAME>
<COLSPEC COLNAME=C2-DBFUNC-ADD>
<COLSPEC COLNAME=C3-DBFUNC-FLUSH>
<COLSPEC COLNAME=C4-DBFUNC-OWNER>
<COLSPEC COLNAME=C5-DBFUNC-PRINT>
<COLSPEC COLNAME=C6-DBFUNC-REMOVE>
<COLSPEC COLNAME=C6-DBFUNC-COUNT>
<THEAD>
<ROW>
  <ENTRY>DB type</ENTRY>
  <ENTRY>add</ENTRY>
  <ENTRY>flush</ENTRY>
  <ENTRY>owner</ENTRY>
  <ENTRY>print</ENTRY>
  <ENTRY>remove</ENTRY>
  <ENTRY>count</ENTRY>
</ROW>
</THEAD>
<!-- <TFOOT> ... </TFOOT> -->
<TBODY>
<ROW>
  <ENTRY>incore</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
</ROW>
<ROW>
  <ENTRY>header</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
</ROW>
<ROW>
  <ENTRY>ordered</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>yes</ENTRY>
</ROW>
<ROW>
  <ENTRY>unordered</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
</ROW>
<ROW>
  <ENTRY>hostsfile</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>no</ENTRY>
</ROW>
<ROW>
  <ENTRY>bind</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>no</ENTRY>
</ROW>
<ROW>
  <ENTRY>ndbm</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
</ROW>
<ROW>
  <ENTRY>gdbm</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
</ROW>
<ROW>
  <ENTRY>dbm</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
</ROW>
<ROW>
  <ENTRY>yp (NIS)</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>no</ENTRY>
</ROW>
<ROW>
  <ENTRY>bhash</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
</ROW>
<ROW>
  <ENTRY>btree</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>yes</ENTRY>
</ROW>
<ROW>
  <ENTRY>ldap</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>no</ENTRY>
</ROW>
<ROW>
  <ENTRY>selfmatch</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>yes</ENTRY>
  <ENTRY>no</ENTRY>
  <ENTRY>yes</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</INFORMALTABLE>


</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.dblookup">
<TITLE><EMPHASIS>dblookup</></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
Does lookup via <FUNCTION>relation</> defined <EMPHASIS>dblookup</>
vector:
<CMDSYNOPSIS>
  <COMMAND>dblookup</>
    <ARG CHOICE=PLAIN><REPLACEABLE>key</></ARG>
    <ARG>
      <ARG> <OPTION>-:</> <REPLACEABLE>defaultkey</></ARG>
            <OPTION>--</> %subst1 %subst2 ... %subst9 </ARG>
</CMDSYNOPSIS>
<CMDSYNOPSIS>
  <COMMAND>dblookup</>
    <ARG CHOICE=PLAIN><REPLACEABLE>key</></ARG>
    <ARG>
      <ARG> <OPTION>-:</> <REPLACEABLE>defaultkey</></ARG>
            <OPTION>--</> %subst2 %subst2 ... %subst9 </ARG>
</CMDSYNOPSIS>
The latter form is for databases which have <EMPHASIS>any</>
driver routine in use!

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM><EMPHASIS>cell</></TERM><LISTITEM><PARA>

Lookup result

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><LITERAL>NULL</></TERM><LISTITEM><PARA>

Lookup failed, variable <LITERAL>$defer</> may be set if the reason is
considered <EMPHASIS>temporary</> and thus solvable latter.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

The '-:' does supply the "final case" lookup key in cases where
various domain shortening lookups reach their end (and have the
builtin ultimate default lookup of ".").

<SCREEN>
  relation -lm%:t $DBTYPE -f $MAILVAR/db/routes$DBEXT routesdb
   ...
  a=$(routesdb $lookupkey -: .:ERROR -- $subst1 $subst2)
</SCREEN>

</PARA><PARA>
With those things the "routes" database can now contain data
like:

<SCREEN>
  .:ERROR  smtp!
  cust.1   smtp!%0
  cust.2   smtp!%0!%1
</SCREEN>

</PARA><PARA>
With "subst*" values below, results would be:

<SCREEN>
  subst1="foo1"
  subst2="foo2"

  smtp!
  smtp!foo1
  smtp!foo1!foo2
</SCREEN>

respectively.

</PARA><PARA>

Note: The %subst things are used only if the relation
definition has -% option flag set!

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

The access function to the database facilities in the 
<COMMAND>router</>.

</PARA><PARA>
<EMPHASIS>FIXME! Notes about %[0-9] substitution rules, and their controls.
(That is: <FUNCTION>relation</>'s <OPTION>-%</> option!
 <XREF LINKEND=zmshref.relation>)
</>

</PARA><PARA>
A complete example of "<OPTION>-:</>" usage from
<FILENAME>p-routes.cf</>:

<SCREEN>
routes_neighbour (domain, address, A) {
    local tmp

    # We have Alternate default-lookup for cases of locally generated
    # ERROR MESSAGES -- for case where the dot (.) leads to error!
    # and we want to reply with DIFFERENT address, thus:  '.:ERROR' key.

    $(iserrormsg) &&
        tmp=$(routesdb "$domain" -: '.:ERROR') &&
            tmp=$(routes_spec "$tmp" "$address" $A) &&
                returns $tmp

    tmp=$(routesdb "$domain") &&
        tmp=$(routes_spec "$tmp" "$address" $A) &&
            returns $tmp

#| The routes_spec function interprets the return value from the
#| routesdb lookup.

    return 1
}
</SCREEN>


</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.echo">
<TITLE><FUNCTION>echo</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>echo</COMMAND>
    <ARG><OPTION>-n</></ARG>
    <ARG><OPTION>--</>
      <ARG CHOICE=PLAIN REP=REPEAT><REPLACEABLE>string-expressions</></>
   </ARG>
</CMDSYNOPSIS>
</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

        

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>-n</></TERM><LISTITEM><PARA>

Don't print newline at end of string.


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>--</></TERM><LISTITEM><PARA>

End the option set, use this if there is even a small change of
starting the the data with the hyphen character.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

none

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.elements">
<TITLE><FUNCTION>elements</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>elements</>
    <ARG CHOICE=PLAIN><REPLACEABLE>lisp-object</></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<EMPHASIS>lisp-object</>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This does a side-effect on input list, which is need in "for" loops:
<SCREEN>
  for loopvar in $(elements $listvar)
  do
    ...
  done
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.envars">
<TITLE><FUNCTION>envars</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>envars</>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>


</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

A debug tool to print internal variable tree.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.erraddron">
<TITLE><FUNCTION>erraddron</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>erraddron</>
    <ARG><REPLACEABLE>file</></>
</CMDSYNOPSIS>
</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Successfull operation.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>64</TERM><LISTITEM><PARA>

Wrong usage of arguments.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

Optional filename.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Without a filename this dissociates the possible
pre-existing logging file definition.

</PARA><PARA>

With a filename option this specifies a filename into which
the router appends all address parsing error messages.
This is primarily for curious postmasters or other collectors
of address trivia.

</PARA><PARA>

This is a debug tool; usage examples:


<SCREEN>
  erraddron $POSTOFFICE/postman/ERRADDRLOG

  erraddron
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.eval">
<TITLE><FUNCTION>eval</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>eval</>
    <ARG CHOICE=PLAIN><REPLACEABLE>expression</></>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

status

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This is the generic workhorse for self-modifying code execution
within the <EMPHASIS>zmsh</>, it creates the workhorse of
following code-fragment:
<SCREEN>
# Usage: newattribute &lt;oldattribute> &lt;key1> &lt;value1> [ &lt;key2> &lt;value2> ] ...
#
# Returns a new attribute list symbol with the &lt;keyN> &lt;valueN>
# attributes added to the contents of the &lt;oldattribute> list.

newattribute (oldattribute) {
        local a null value

        a=$(gensym)
        eval $a=\$$oldattribute
        while [ "$#" != 0 ];
        do
                lreplace $a "$1" "$2"
                shift ; shift
        done
        echo -- "$a"
}
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.exit">
<TITLE><FUNCTION>exit</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>exit</>
</CMDSYNOPSIS>
</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

does not return, does <FUNCTION>exit(2)</> for the shell/router..

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes: </TERM><LISTITEM><PARA>

Exit from the shell/router with exit code.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.export">
<TITLE><FUNCTION>export</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>export</>
    <ARG REP=REPEAT><REPLACEABLE>variable-name</></ARG>
</CMDSYNOPSIS>
</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

??? FIXME

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Exports variable name(s). If no variables are given, 
export prints a list of which variables have been exported.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.filepriv">
<TITLE><FUNCTION>filepriv</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>filepriv</>
    <ARG CHOICE=PLAIN><REPLACEABLE>file</></ARG>
    <ARG><REPLACEABLE>uid</></>
</CMDSYNOPSIS>
</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

??? FIXME

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>1</TERM><LISTITEM><PARA>

Error.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Prints the numeric user id of the least 
privileged account that can modify the specified file.
</PARA>

<PARA>
This is determined by an approximation that pessimistically assumes that 
any file or directory writable by group or others is insecure, and
optimistically assumes that it is enough to check a file and its parent
directory instead of all the way to the filesystem root.
The reason for the latter is that if grandparent directories are insecure,
the system is likely to have just as bad potential problems as can be
created by using mail to run processes with forged powers (besides, doing
the full check would be quite expensive).
</PARA>

<PARA>
If a second argument is given, it is the numeric user id to assume 
for the file. This means only the parent directory will be checked 
for nonwritability and for having the same (or a 0) uid.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.first">
<TITLE><FUNCTION>first</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>first</>
    <ARG CHOICE=PLAIN><REPLACEABLE>object-reference</></ARG>
</CMDSYNOPSIS>
</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

Pointer to copied lisp-object of object-reference's
<LINK LINKEND="zmshref.car"><CITETITLE><FUNCTION>car</></></LINK>
operation.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This command is synonymous to the
<LINK LINKEND="zmshref.car"><CITETITLE><FUNCTION>car</></></LINK>
(at <XREF LINKEND="zmshref.car">), and
<LINK LINKEND="zmshref.channel"><CITETITLE><FUNCTION>channel</></></LINK>
(at <XREF LINKEND="zmshref.channel">) commands.  

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.gensym">
<TITLE><FUNCTION>gensym</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
 <COMMAND>gensym</>
</CMDSYNOPSIS>
</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>



</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Generates and prints a new symbol name in the 
sequence <VARNAME>g0</> to <VARNAME>gN</> every time it is called. The 
sequence is reset and any symbol values destroyed after the <COMMAND>router</>
has processed a message. This function is used to generate new symbols, to 
hold attached address property lists, during alias expansion.
</PARA><PARA>
Code-fragment showing a way how it is used inside the router scripts:
<SCREEN>
# Usage: newattribute &lt;oldattribute> &lt;key1> &lt;value1> [ &lt;key2> &lt;value2> ] ...
#
# Returns a new attribute list symbol with the &lt;keyN> &lt;valueN>
# attributes added to the contents of the &lt;oldattribute> list.

newattribute (oldattribute) {
        local a null value

        a=$(gensym)
        eval $a=\$$oldattribute
        while [ "$#" != 0 ];
        do
                lreplace $a "$1" "$2"
                shift ; shift
        done
        echo -- "$a"
}
</SCREEN>


</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.get">
<TITLE><FUNCTION>get</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
 <COMMAND>get</COMMAND>
   <ARG CHOICE=PLAIN>property-list</ARG>
   <ARG CHOICE=PLAIN>keyname</ARG>

 <COMMAND>get</COMMAND>
   <ARG CHOICE=PLAIN>property-list-varname</ARG>
   <ARG CHOICE=PLAIN>keyname</ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

property-list

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Returns a property-list corresponding to key string:
<SCREEN>
  listvar=(key1 value1 keyname value key3 value3)
  result1=$(get  listvar keyname)
  result2=$(get $listvar keyname)
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.getopts">
<TITLE><FUNCTION>getopts</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>getopts</>
    <ARG CHOICE=PLAIN><REPLACEABLE>optstring-name</></ARG>
    <ARG REP=REPEAT>arguments</ARG>
</CMDSYNOPSIS>
</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

success ?

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>1</TERM><LISTITEM><PARA>

Error.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Never used inside the <EMPHASIS>zmsh</> scripts,
usefullness questionable, and usage documentation
missing.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.grind">
<TITLE><FUNCTION>grind</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>grind</>
    <ARG CHOICE=PLAIN><REPLACEABLE>lisp-object</></>
</CMDSYNOPSIS>
</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

Pointer to list of <EMPHASIS>varcell</>.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This is a debug tool.

</PARA><PARA>

The side-effect is to output the text form of the <EMPHASIS>lisp-object</>.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.groupmembers">
<TITLE><FUNCTION>groupmembers</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>groupmembers</>
    <ARG CHOICE=PLAIN><REPLACEABLE>groupname</></>
</CMDSYNOPSIS>
</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Found data, side-effect is described below.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>1</TERM><LISTITEM><PARA>

Didn't find anything.  No side-effects.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>64</TERM><LISTITEM><PARA>

Usage (number of arguments) is wrong.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Prints the accounts that are listed as members of a group in
the system groups file, one per line.
Note that accounts with the same login group id, but that are 
not listed in the groups file, will not appear in this list.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.hash">
<TITLE><FUNCTION>hash</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>hash</>
    <ARG><OPTION>-r</></>
    <ARG><REPLACEABLE>command names</></>
</CMDSYNOPSIS>
</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

This value is returned always.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>-r</></TERM><LISTITEM><PARA>

Path is flushed.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><REPLACEABLE>command names</></TERM><LISTITEM><PARA>

These are looked up one by one via the PATH environment variable,
and results are stored into internal quick-access hash table.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This is a part of the "<EMPHASIS>zmsh</>" shell-script
interpreter in good SH-tradition, but is not used in the
ZMailer <EMPHASIS>router</> in any way.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.homedirectory">
<TITLE><FUNCTION>homedirectory</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>homedirectory</>
    <ARG CHOICE=PLAIN><REPLACEABLE>user</></>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Found home directory, side-effect is printing of that
directory into <LITERAL>stdout</>, whence it may be captured into
e.g. some variable.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>2</TERM><LISTITEM><PARA>

Error, no such user.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>3</TERM><LISTITEM><PARA>

Error, some temporary lookup failure.
Also sets "$defer" variable.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>64</TERM><LISTITEM><PARA>

Usage error, wrong number of arguments. (Usage.)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Prints the home directory of the specified user account.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.host">
<TITLE><FUNCTION>host</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
 <COMMAND>host</>
   <ARG CHOICE=PLAIN><REPLACEABLE>object-reference</></>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

The host (2nd) component of an address quad.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

none

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.hostname">
<TITLE><FUNCTION>hostname</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>hostname</> <ARG><REPLACEABLE>name</></>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Returns always this value.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Sets the <EMPHASIS>router</>'s idea of the system hostname.
Without an argument the name is retrieved from the system and printed.
The <EMPHASIS>router</> has no preconceived notion of what the hostname
is, so "Message-Id:" and "Received:' headers will only be generated
if a "hostname" has been set using this function.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>

</SECT2>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.ifssplit">
<TITLE><FUNCTION>ifssplit</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>ifssplit</>
   <ARG CHOICE=PLAIN><REPLACEABLE>any-string</></>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

split list

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This splits given input string per IFS environment variable, and
produces a list of substrings ready for further use.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>

</SECT2>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.lappend">
<TITLE><FUNCTION>lappend</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>lappend</>
    <ARG CHOICE=PLAIN><REPLACEABLE>varname</></>
    <ARG CHOICE=PLAIN><REPLACEABLE>anyvalue</></>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

NULL; actually error cases output to <LITERAL>stderr</>, all others are
handled <EMPHASIS>silently</>.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This appends content of list object (<EMPHASIS>anyvalue</>) to named
<EMPHASIS>varname</> variable:

<SCREEN>
#
# From  aliases.cf  of system standard scripts.
#

maprrouter (attribute, localpart, origaddr, plustail, domain) {
    local shh al

    al=()
    while read address
    do
        case "$address" in
        ") shh=(((error expansion "$localpart")))
            lappend al $shh
            continue
            ;;
        esac

        defer="
        shh=$(rrouter "$address" "$origaddr" $attribute \
             "$plustail" "$domain")
        [ -n "$defer" ] &&
            shh=(((hold "$defer" "$address" $attribute)))
        defer="
        lappend al $shh
    done
    returns $al
}

</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>

</SECT2>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.last">
<TITLE><FUNCTION>last</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>last</>
    <ARG CHOICE=PLAIN><REPLACEABLE>lisp-object</></>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

Return a pointer to last cell of 
<EMPHASIS>varcell</>'s list.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This is actually a unused relict from way way back..

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>

</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.length">
<TITLE><FUNCTION>length</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
 <COMMAND>length</>
   <ARG CHOICE=PLAIN><REPLACEABLE>lisp-object</></>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

String of decimal numbers representing the number of <EMPHASIS>varcell</>'s 
in the lisp-object primary chain.


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This counts the number of elements in the chain, not
length of any string.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.list">
<TITLE><FUNCTION>list</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
 <COMMAND>list</>
   <ARG CHOICE=PLAIN REP=REPEAT><REPLACEABLE>objects</></>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

List-wrapped lisp-object.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

<SCREEN>
<PROMPT>z# </><USERINPUT>list 1 2 3</>
(1 2 3)
<PROMPT>z# </><USERINPUT>tt=(1 2 3)</>
<PROMPT>z# </><USERINPUT>list $tt</>
((1 2 3))
<PROMPT>z# </><USERINPUT>tt=$(list 1 2 3)</>
<PROMPT>z# </><USERINPUT>grind $tt</>
(1 2 3)
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.listaddresses">
<TITLE><FUNCTION>listaddresses</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
 <COMMAND>listaddresses</>
  <ARG><OPTION>-e</> <REPLACEABLE>error-address</></ARG>
  <ARG><OPTION>-E</> <REPLACEABLE>errors-to-address</></ARG>
  <ARG><OPTION>-c</> <REPLACEABLE>comment</></ARG>
</CMDSYNOPSIS>

</PARA><PARA>
The <LITERAL>stdin</> feeds in the list of addresses.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>lisp-list</TERM><LISTITEM><PARA>

Successfull processing result.
There can still be an error-report sent to the error-address; see below.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>NULL</TERM><LISTITEM><PARA>

Error, <LITERAL>stderr</> gets an error report text,
and in some cases also the "<OPTION>-e</>" defined
error-address, and "postmaster" will get email telling
of problems in the file.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>-e</></TERM><LISTITEM><PARA>

Any syntax errors at list parsing will cause a 
report to be mailed to the given address.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-E</></TERM><LISTITEM><PARA>

If an error occurs while messages are being delivered, 
the `errors-to-address' can be used to force error message destination 
elsewhere than to the default `sender' of the message.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-c</></TERM><LISTITEM><PARA>

A comment will be inserted in the error report.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Filters an RFC822 address list on standard input 
to produce one normal form (no non-address tokens) address per line on 
its output. This function can be used to parse the alias file or .forward 
files or similar.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.listexpand">
<TITLE><FUNCTION>listexpand</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>listexpand</>
    <ARG><OPTION>-c</> <REPLACEABLE>comment</></ARG>
    <ARG><OPTION>-e</> <REPLACEABLE>error-address</></ARG>
    <ARG><OPTION>-E</> <REPLACEABLE>errors-to-address</></ARG>
    <ARG><OPTION>-p</> <REPLACEABLE>privilege-integer</></ARG>
    <ARG><OPTION>-N</> <REPLACEABLE>notary-string</></ARG>
    <ARG CHOICE=PLAIN><REPLACEABLE>$attribute</></>
    <ARG CHOICE=PLAIN><REPLACEABLE>$localpart</></>
    <ARG CHOICE=PLAIN><REPLACEABLE>$origaddr</></>
    <ARG><REPLACEABLE>$plustail</>
      <ARG><REPLACEABLE>$domain</></ARG></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

lisp-list (or NULL)

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>-e</></TERM><LISTITEM><PARA>

Any syntax errors at list 
parsing will cause a report to be mailed to the given address.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-E</></TERM><LISTITEM><PARA>

If an error occurs while messages 
are being delivered, the "errors-to-address" can be used to force error 
message destination elsewhere than to the default "sender" of the message.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-c</></TERM><LISTITEM><PARA>

A comment will be inserted in the error report.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-p</></TERM><LISTITEM><PARA>

Integer privilege code for expanded addresses

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-N</></TERM><LISTITEM><PARA>

Notary string data, or "-" for "no DNS".

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This implements the most common pipeline where <LINK
LINKEND="zmshref.listaddresses"><CITETITLE><FUNCTION>listaddresses</></></LINK>
(at <XREF LINKEND="zmshref.listaddresses">)
was used with more efficient memory consumption handling.
(System memory usage internals have changed over the time, and now
 this is no longer especially great memory expenditure saver.)

</PARA><PARA>
The <LITERAL>stdin</> will feed addresses from a file for parsing, and
parameter mapping + routing.

</PARA><PARA>
Comparison of previous <LINK LINKEND="zmshref.listaddresses"><CITETITLE>
<FUNCTION>listaddresses</></></LINK>  (at
<XREF LINKEND="zmshref.listaddresses">) -script implemented code,
and new one using the <FUNCTION>listexpand</>:

</PARA><PARA>
Old:
<SCREEN>
    l="$preowner$(basename "$lcuser" -mod)$postowner"
    nattr=$(newattribute $attr privilege $priv sender "$l")
    $(zapDSNnotify $nattr delivered "$sender" "$lcuser$domain")
    a=$(runas $priv cat "$a" | \
        listaddresses       -E "$l$domain"          \
                            -e "$l"                 \
                            -c "$a file expansion" |
        maprrouter $nattr "$a" "$host" "$plustail"  \
                    "$domain")
    postzapDSNnotify a
    returns $a
</SCREEN>
</PARA><PARA>
New:
<SCREEN>
    l="$preowner$(basename "$lcuser" -mod)$postowner"
    if priv=$(getpriv "664" $priv "$a" maillist) &&
       nattr=$(newattribute $attr privilege $priv sender "$l") ; then
        $(zapDSNnotify $nattr delivered "$sender" "$lcuser$domain")
        a=$(runas $priv cat "$a" | \
            listexpand      -E "$l" -e "$l" -p $priv        \
                            -c "$a file expansion"          \
                            $nattr  "$a" "$host" "" "$domain" )
        postzapDSNnotify a
        returns $a
    fi
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.login2uid">
<TITLE><FUNCTION>login2uid</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
 <COMMAND>login2uid</>
  <ARG CHOICE=PLAIN><REPLACEABLE>username</></>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>"nobody-uid"</TERM><LISTITEM><PARA>

Either uid of "nobody", or no lookup match for given userid.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>uid</TERM><LISTITEM><PARA>

UID of user.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Prints the uid associated with the specified account name, if any.
A side-effect is to add the GECOS name field of the account to
the <EMPHASIS>fullname</> in-core database, to add the login name to
uid mapping to the <EMPHASIS>pwnam</> in-core database, and to add
the uid to login name mapping to the <EMPHASIS>pwuid</> in-core database.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.lreplace">
<TITLE><FUNCTION>lreplace</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM><EMPHASIS>Syntax1:</></TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
 <COMMAND>lreplace</>
   <ARG CHOICE=PLAIN><REPLACEABLE>varname</></>
   <ARG CHOICE=PLAIN><REPLACEABLE>indexnum</></>
   <ARG CHOICE=PLAIN><REPLACEABLE>anyvalue</></>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><EMPHASIS>Syntax2:</></TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>lreplace</>
   <ARG CHOICE=PLAIN><REPLACEABLE>varname</></>
   <ARG CHOICE=PLAIN><REPLACEABLE>fieldname</></>
   <ARG CHOICE=PLAIN><REPLACEABLE>anyvalue</></>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

none

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This replaces designated field on <EMPHASIS>varname</> variable containing
list-like data with <EMPHASIS>anyvalue</> value.
</PARA>

<PARA>
The field designation can be given in numeric form, where
the field index can be numeric (first field is zero), or
<EMPHASIS>keyname</> on key/value pair list.
</PARA>

<PARA>
If a key is not found (with key/value pairs), then designated pair
is added to the list.
</PARA>

<SCREEN>
  <PROMPT>z$ </><USERINPUT>tt=(aa 11 bb 22 cc 33 dd 44)</>
  <PROMPT>z$ </><USERINPUT>grind $tt</>
  (aa 11 bb 22 cc 33 dd 44)
  <PROMPT>z$ </><USERINPUT>lreplace tt bb zz</>
  <PROMPT>z$ </><USERINPUT>grind $tt</>
  (aa 11 bb zz cc 33 dd 44)
  <PROMPT>z$ </><USERINPUT>lreplace tt 0 aaa</>
  <PROMPT>z$ </><USERINPUT>grind $tt</>
  (aaa 11 bb 22 cc 33 dd 44)
  <PROMPT>z$ </><USERINPUT>lreplace tt zz aa</>
  <PROMPT>z$ </><USERINPUT>grind $tt</>
  (aaa 11 bb 22 cc 33 dd 44 zz aa)
</SCREEN>

<PARA>
This is an example of "<FUNCTION>lreplace</>" use in the scripts:
</PARA>

<SCREEN>
# Usage: newattribute &lt;oldattribute> &lt;key1> &lt;value1> [ &lt;key2> &lt;value2> ] ...
#
# Returns a new attribute list symbol with the &lt;keyN> &lt;valueN>
# attributes added to the contents of the &lt;oldattribute> list.

newattribute (oldattribute) {
        local a null value

        a=$(gensym)
        eval $a=\$$oldattribute
        while [ "$#" != 0 ];
        do
                lreplace $a "$1" "$2"
                shift ; shift
        done
        echo -- "$a"
}
</SCREEN>

<PARA>
A fragment of code from inside the <FILENAME>crossbar.cf</> shows
different usages:
</PARA>

<SCREEN>
....
    usenet)
        lreplace from 2 "$(uucproute "$(user $from)")"
        tsift $(user $from) in
        $hostname!.*    ;;
        .*    
            lreplace from 2 $hostname!$(user $from)
            ;;
        tfist
        # newsgroup name only
        lreplace to 2 "$(localpart "$(user $to)")"
        ;;
....
</SCREEN>

</LISTITEM></VARLISTENTRY>
</VARIABLELIST>

</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.malcontents">
<TITLE><FUNCTION>malcontents</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<SYNOPSIS>
  <COMMAND>malcontents</>
</SYNOPSIS>
</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

ZMSH Debugging thing.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.printaliases">
<TITLE><FUNCTION>printaliases</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>printaliases</>
    <ARG><OPTION>-v</></ARG>
    <ARG><OPTION>-o</> <REPLACEABLE>indexoutputfile</></ARG>
    <ARG CHOICE='PLAIN'><REPLACEABLE>file</></>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>



</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>1</TERM><LISTITEM><PARA>

Error.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>-v</></TERM><LISTITEM><PARA>

Verbose.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-o</> <REPLACEABLE>indexoutputfile</></TERM><LISTITEM><PARA>

Each header line will also generate 
a "header TAB byteoffset" line in the indexfile.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This function was used  by the "<EMPHASIS>newaliases(1)</>" program to
generate the aliases database from a source file.

</PARA><PARA>
That task has been moved into "<LINK LINKEND="zref-zmailer-newdb">
<CITETITLE><COMMAND>zmailer newdb</></></LINK>"
(at <XREF LINKEND="zref-zmailer-newdb">) process,
along with all other router database refreshment tasks.

</PARA><PARA>

Reads RFC822 syntax header lines from the specified
file, parses them assuming contents must be an address list, and sorts 
and prints the header lines with all addresses in normal form. Comments 
are allowed; they extend from the character "#" at the beginning of 
a line, or after an address, to the end of line.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.process">
<TITLE><FUNCTION>process</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>process</>
    <ARG CHOICE=PLAIN><REPLACEABLE>messagefile</></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Successfull processing.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>100</TERM><LISTITEM><PARA>

File name parameter missing.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>other</TERM><LISTITEM><PARA>

Return value from the underlying scripts.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

The protocol switch function.
It is called by the "<LINK LINKEND="zmshref.daemon"><CITETITLE>
<FUNCTION>daemon</></></LINK>" function (at <XREF LINKEND="zmshref.daemon">)
to process a message found in the
<FILENAME CLASS=DIRECTORY>$POSTOFFICE/router/</> directory.
</PARA><PARA>

This function will in turn call an internal protocol-specific function
which knows the syntax and semantics of the message file.
The current version knows about messages submitted using the
<LITERAL>MSG_RFC822</> parameter to <EMPHASIS>mail_open(3)</>.
For that case, the protocol function is called "<FUNCTION>rfc822</>".

</PARA><PARA>

<EMPHASIS>router</> has a bit more complex directory semantics,
than is stated above.
See "<EMPHASIS>zmailer(3)</>" for details. 

</PARA><PARA>

Although the "<FUNCTION>process</>" function is provided built in,
it is usually overridden by a defined function in the <EMPHASIS>router</>
configuration file.  (See <FILENAME>process.cf</>, and
the entrypoint text at <XREF LINKEND="zmshref.wke.process">)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.read">
<TITLE><FUNCTION>read</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>read</>
    <ARG CHOICE=PLAIN REP=REPEAT><REPLACEABLE>variable</></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Successful read.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>1</TERM><LISTITEM><PARA>

Error. (End of input)

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>64</TERM><LISTITEM><PARA>

Error. Missing mandatory variable name. (Usage.)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

The <FUNCTION>read</> will get one line of input,
and if there are more than one variable name parameter,
split it at the whitespaces (IFS chars).
</PARA><PARA>

There appears to be a bug when there are less IFS separated
sequences than there are varnames: The extra varnames do get
things at a bit random.. (2001-Oct-15)
</PARA><PARA>

If input line is zero length (or all IFS chars), the <FUNCTION>read</>
will read another input line.

</PARA><PARA>
If the input line ends with character: "\" as its very last, the line
gets a catenation of next input line effectively unfolding multiline
coded string.

<SCREEN>
<PROMPT>z# </><USERINPUT>echo "1 2 3 4 5" | read v1 v2</>
<PROMPT>z# </><USERINPUT>echo $?</>
0
<PROMPT>z# </><USERINPUT>echo $v1</>
1
<PROMPT>z# </><USERINPUT>echo $v2</>
2 3 4 5
<PROMPT>z# </><USERINPUT>echo "11111" | read v1 v2</>
<PROMPT>z# </><USERINPUT>echo $?</>
0
<PROMPT>z# </><USERINPUT>echo $v1</>
11111
<PROMPT>z# </><USERINPUT>echo $v2</>
11111
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.recase">
<TITLE><FUNCTION>recase</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
 <COMMAND>recase</>
   <GROUP>
      <ARG><OPTION>-u</></ARG>
      <ARG><OPTION>-l</></ARG>
      <ARG><OPTION>-p</></ARG>
   </GROUP>
   <ARG CHOICE=PLAIN> <OPTION>--</> <REPLACEABLE>string</></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Success, <LITERAL>stdout</> gets the result string.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>64</TERM><LISTITEM><PARA>

Bad option. (Usage.)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>--</TERM><LISTITEM><PARA>

End options.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>-u</TERM><LISTITEM><PARA>

Convert into uppercase.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>-l</TERM><LISTITEM><PARA>

Convert into lowercase.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>-p</TERM><LISTITEM><PARA>

Prettify.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

A case-mapping function that prints the parameter string
in either all-uppercase, all-lowercase, or capitalized (pretty).

</PARA><PARA>
The input to be converted is expected to be single string, e.g.
not multiple strings.

</PARA><PARA>
Due to internal use of "getopt" for parameter pickup,
if there is even the slightest change that the string begins
with a hyphen (minus) character, invocation must use
the -- pair to end the options, and to protect the parameter.

</PARA><PARA>
Typical use in the router scripts:
<SCREEN>
   lcuser="$(recase -l -- "$user")"
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.recipient">
<TITLE><FUNCTION>recipient</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>recipient</>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>1</TERM><LISTITEM><PARA>

Is a recipient address.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Is not.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

A boolean function that returns the value of the statement
"executing a header rewriting function and the address 
is a recipient address in a message header".

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.relation">
<TITLE><FUNCTION>relation</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
Generic:
<CMDSYNOPSIS>
  <COMMAND>relation</COMMAND>
  <ARG><OPTION>-i</></ARG>
  <ARG><OPTION>-T</></ARG>
  <ARG CHOICE=PLAIN><OPTION>-t <REPLACEABLE>dbtype</></><ARG><OPTION>/<REPLACEABLE>subtype</></></ARG></ARG>
  <ARG><OPTION>-f <REPLACEABLE>file</REPLACEABLE></></ARG>
  <ARG><OPTION>-e <REPLACEABLE>#</></></ARG>
  <ARG><OPTION>-s <REPLACEABLE>#</></></ARG>
  <ARG><OPTION>-:%blmnu</></ARG>
  <ARG><OPTION>-d <REPLACEABLE>driver</></></ARG>
  <ARG><OPTION>-C <REPLACEABLE>configfile</></></ARG>
  <ARG CHOICE=PLAIN><OPTION><REPLACEABLE>name</></></ARG>
</CMDSYNOPSIS>
The separator character between "dbtype" and "subtype" can be either
a comma (",") or a slash ("/"), as user wishes.
In case the subtype is a filepath (or otherwise begins with a slash),
the user propably wants to use comma to reduce confusion.
</PARA><PARA>
More specific versions:
<CMDSYNOPSIS>

  <COMMAND>relation</COMMAND>
  <ARG CHOICE=PLAIN><OPTION>-t yp,<REPLACEABLE>yp-mapname</></></ARG>
  <ARG CHOICE=PLAIN><OPTION>-f <REPLACEABLE>yp-domain</></></ARG>
  <ARG><OPTION>-e <REPLACEABLE>#</></></ARG>
  <ARG><OPTION>-s <REPLACEABLE>#</></></ARG>
  <ARG><OPTION>-:%blmnu</></ARG>
  <ARG><OPTION>-d <REPLACEABLE>driver</></></ARG>
  <ARG CHOICE=PLAIN><OPTION><REPLACEABLE>name</></></ARG>

  <COMMAND>relation</COMMAND>
  <ARG CHOICE=PLAIN><OPTION>-t bind/<REPLACEABLE>query-type</></></ARG>
  <ARG>-f <REPLACEABLE>file</REPLACEABLE></ARG>
  <ARG>-e <REPLACEABLE>#</></ARG>
  <ARG>-s <REPLACEABLE>#</></ARG>
  <ARG>-:%blmnu</ARG>
  <ARG>-d <REPLACEABLE>driver</></ARG>
  <ARG CHOICE=PLAIN><OPTION><REPLACEABLE>name</></></ARG>

  <COMMAND>relation</COMMAND>
  <ARG CHOICE=PLAIN><OPTION>-i</></ARG>
  <ARG CHOICE=PLAIN><OPTION>-t ordered,<REPLACEABLE>filepath2</></></ARG>
  <ARG CHOICE=PLAIN><OPTION>-f <REPLACEABLE>filepath1</REPLACEABLE></></ARG>
  <ARG CHOICE=OPT><OPTION>-e <REPLACEABLE>#</></></ARG>
  <ARG CHOICE=OPT><OPTION>-s <REPLACEABLE>#</></></ARG>
  <ARG CHOICE=OPT><OPTION>-:%blmnu</></ARG>
  <ARG CHOICE=OPT><OPTION>-d <REPLACEABLE>driver</></></ARG>
  <ARG CHOICE=PLAIN><OPTION><REPLACEABLE>name</></></ARG>

  <COMMAND>relation</COMMAND>
  <ARG CHOICE=PLAIN><OPTION>-i</></ARG>
  <ARG CHOICE=PLAIN><OPTION>-t unordered,<REPLACEABLE>filepath2</></></ARG>
  <ARG CHOICE=PLAIN><OPTION>-f <REPLACEABLE>filepath1</REPLACEABLE></></ARG>
  <ARG CHOICE=OPT><OPTION>-e <REPLACEABLE>#</></></ARG>
  <ARG CHOICE=OPT><OPTION>-s <REPLACEABLE>#</></></ARG>
  <ARG CHOICE=OPT><OPTION>-:%blmnu</></ARG>
  <ARG CHOICE=OPT><OPTION>-d <REPLACEABLE>driver</></></ARG>
  <ARG CHOICE=PLAIN><OPTION><REPLACEABLE>name</></></ARG>

  <COMMAND>relation</COMMAND>
  <ARG CHOICE=PLAIN><OPTION>-t ordered</></ARG>
  <ARG CHOICE=PLAIN><OPTION>-f <REPLACEABLE>filepath</REPLACEABLE></></ARG>
  <ARG CHOICE=OPT><OPTION>-e <REPLACEABLE>#</></></ARG>
  <ARG CHOICE=OPT><OPTION>-s <REPLACEABLE>#</></></ARG>
  <ARG CHOICE=OPT><OPTION>-:%blmnu</></ARG>
  <ARG CHOICE=OPT><OPTION>-d <REPLACEABLE>driver</></></ARG>
  <ARG CHOICE=PLAIN><OPTION><REPLACEABLE>name</></></ARG>

  <COMMAND>relation</COMMAND>
  <ARG CHOICE=PLAIN><OPTION>-t unordered</></ARG>
  <ARG CHOICE=PLAIN><OPTION>-f <REPLACEABLE>filepath</REPLACEABLE></></ARG>
  <ARG CHOICE=OPT><OPTION>-e <REPLACEABLE>#</></></ARG>
  <ARG CHOICE=OPT><OPTION>-s <REPLACEABLE>#</></></ARG>
  <ARG CHOICE=OPT><OPTION>-:%blmnu</></ARG>
  <ARG CHOICE=OPT><OPTION>-d <REPLACEABLE>driver</></></ARG>
  <ARG CHOICE=PLAIN><OPTION><REPLACEABLE>name</></></ARG>

  <COMMAND>relation</COMMAND>
  <ARG CHOICE=PLAIN><OPTION>-t <REPLACEABLE>dbtype</></></ARG>
  <ARG><OPTION>-f <REPLACEABLE>file</REPLACEABLE></></ARG>
  <ARG><OPTION>-e <REPLACEABLE>#</></></ARG>
  <ARG><OPTION>-s <REPLACEABLE>#</></></ARG>
  <ARG><OPTION>-:%blmnu</></ARG>
  <ARG><OPTION>-d <REPLACEABLE>driver</></></ARG>
  <ARG CHOICE=PLAIN><OPTION><REPLACEABLE>name</></></ARG>

</CMDSYNOPSIS>
Note:  "<COMMAND>zmailer newdb</>" does not support "<OPTION>-i</>"
option use! (FIXME! FIXME! 2001-Mar-8)
</PARA><PARA>
Special support for testing of presence of support for given
<REPLACEABLE>dbtype</>:
<CMDSYNOPSIS>

  <COMMAND>relation</COMMAND>
  <ARG CHOICE=PLAIN><OPTION>-T -t <REPLACEABLE>dbtype</></></ARG>
  <ARG CHOICE=PLAIN><REPLACEABLE>dummy_name</></ARG>
</CMDSYNOPSIS>
</PARA>


<PARA>
Options are listed below. <OPTION>name</> is the name of the relation
that is wanted to be created. Examples:
<SCREEN>
relation -t bind,mx mxhost
relation -t ordered -f $MAILVAR/db/routes routes
relation -t ordered -b -f /usr/lib/news/active.sorted newsgroups
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Relation is reated successfully, however possible database access are
not tried yet.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>1..7</TERM><LISTITEM><PARA>

Error.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>-T</OPTION></TERM><LISTITEM><PARA>

Special flag enabling script to test for given db-type:

<SCREEN>
  relation -T -t btree dummy && echo "have BTREE database"
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-t <REPLACEABLE>dbtype</>[,<REPLACEABLE>subtype</>]</OPTION></TERM><LISTITEM><PARA>
Below is a table to option interdependencies as they
apply with different database types.
</PARA>

<FIGURE PGWIDE=1 FLOAT=1>
<TITLE><FUNCTION>relation</>'s option interdependencies</TITLE>
<INFORMALTABLE FRAME=ALL ID=tbl.zmshref.relation>
<TGROUP COLS=3 ALIGN=LEFT COLSEP=0 ROWSEP=0>
<!-- <COLSPEC COLNAME=C1-MTANAME>
     <COLSPEC COLNAME=C2-DNS-CONC>
     <COLSPEC COLNAME=C3-SMTP-CONC>
     <COLSPEC COLNAME=C4-SMTP-PGB> -->
<THEAD>
<ROW>
  <ENTRY>Db-Type</ENTRY>
  <ENTRY>Subtype meaning</ENTRY>
  <ENTRY><OPTION>-f</> option value</ENTRY>
</ROW>
</THEAD>
<!-- <TFOOT>
    </TFOOT> -->
<TBODY>
<ROW>
  <ENTRY>incore</ENTRY>
  <ENTRY>ignored</ENTRY>
  <ENTRY>ignored</ENTRY>
</ROW>
<ROW>
  <ENTRY>header</ENTRY>
  <ENTRY>ignored</ENTRY>
  <ENTRY>ignored</ENTRY>
</ROW>

<ROW>
  <ENTRY>selfmatch</ENTRY>
  <ENTRY>ignored</ENTRY>
  <ENTRY>ignored</ENTRY>
</ROW>
<ROW>
  <ENTRY>hostsfile</ENTRY>
  <ENTRY>ignored</ENTRY>
  <ENTRY>ignored (?)</ENTRY>
</ROW>

<ROW>
  <ENTRY>ordered</ENTRY>
  <ENTRY>ignored (without <OPTION>-i</> option)</ENTRY>
  <ENTRY>path-to-file</ENTRY>
</ROW>
<ROW>
  <ENTRY>unordered</ENTRY>
  <ENTRY>ignored (without <OPTION>-i</> option)</ENTRY>
  <ENTRY>path-to-file</ENTRY>
</ROW>
<ROW>
  <ENTRY>ordered</ENTRY>
  <ENTRY>path-to-file-2 (with <OPTION>-i</> option)</ENTRY>
  <ENTRY>path-to-file-1</ENTRY>
</ROW>
<ROW>
  <ENTRY>unordered</ENTRY>
  <ENTRY>path-to-file-2 (with <OPTION>-i</> option)</ENTRY>
  <ENTRY>path-to-file-1</ENTRY>
</ROW>

<ROW>
  <ENTRY>bind</ENTRY>
  <ENTRY>DNS-query-subtype</ENTRY>
  <ENTRY>ignored</ENTRY>
</ROW>
<ROW>
  <ENTRY>yp</ENTRY>
  <ENTRY>YP-mapname</ENTRY>
  <ENTRY>YP-domain</ENTRY>
</ROW>
<ROW>
  <ENTRY>ldap</ENTRY>
  <ENTRY>ignored??</ENTRY>
  <ENTRY>path-to-cfg-file</ENTRY>
</ROW>

<ROW>
  <ENTRY>dbm</ENTRY>
  <ENTRY>ignored</ENTRY>
  <ENTRY>basepath-to-db-file</ENTRY>
</ROW>
<ROW>
  <ENTRY>ndbm</ENTRY>
  <ENTRY>ignored</ENTRY>
  <ENTRY>basepath-to-db-file</ENTRY>
</ROW>
<ROW>
  <ENTRY>gdbm</ENTRY>
  <ENTRY>ignored</ENTRY>
  <ENTRY>basepath-to-db-file</ENTRY>
</ROW>
<ROW>
  <ENTRY>btree</ENTRY>
  <ENTRY>ignored</ENTRY>
  <ENTRY>basepath-to-db-file</ENTRY>
</ROW>
<ROW>
  <ENTRY>bhash</ENTRY>
  <ENTRY>ignored</ENTRY>
  <ENTRY>basepath-to-db-file</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</INFORMALTABLE>
</FIGURE>

<PARA>
One of the known types of databases, currently: 

<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>incore</></TERM><LISTITEM><PARA>

A database maintained in virtual memory (using splay trees).
This type should not be used for any database that must 
periodically be flushed, since all occupied memory can be freed.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>header</></TERM><LISTITEM><PARA>

A special incore database type used to store RFC822 header 
semantics information. It is unlikely to be used for anything else.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>ordered</></TERM><LISTITEM><PARA>

The <OPTION>-f</>-option defines the path of the file.

</PARA><PARA>

A file with key-value pairs on every line, separated by whitespace,
sorted by key. (See <COMMAND>sort</>(1).)

<SCREEN>
key_at_line_start   data at the same line
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>unordered</></TERM><LISTITEM><PARA>

The <OPTION>-f</>-option defines the path of the file.

</PARA><PARA>

A file with key-value pairs on every line, separated by whitespace. 

<SCREEN>
key_at_line_start   data at the same line
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>ordered,<REPLACEABLE>path-to-file-2</></></><LISTITEM><PARA>

The <OPTION>-f</>-option defines the path of the file-1.

</PARA><PARA>

The version for antique "<OPTION>-i</>" mode.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>unordered,<REPLACEABLE>path-to-file-2</></></><LISTITEM><PARA>

The <OPTION>-f</>-option defines the path of the file-1.

</PARA><PARA>

The version for antique "<OPTION>-i</>" mode.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>hostsfile</></TERM><LISTITEM><PARA>

The <OPTION>-f</>-option defines the path of the file.
(In theory...)

</PARA><PARA>

A rather theorethical database looking into <EMPHASIS>hosts(5)</>
database file (often <FILENAME>/etc/hosts</>).

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>bind/query-subtype</></TERM><LISTITEM><PARA>

The <OPTION>-f</>-option defines the path of the resolver configuration file.
(Not implemented!)

</PARA><PARA>

The BIND implementation of a Domain Name System 
resolver. The subtype for this type is the name of a Resource Record 
type in the <LITERAL>IN</> class.

</PARA><PARA>
Supported subtypes are:
<SIMPLELIST TYPE=INLINE>
 <MEMBER>A</>
 <MEMBER>AAAA</>
 <MEMBER>ANY</>
 <MEMBER>CNAME</>
 <MEMBER>MX</>
 <MEMBER>MXLOCAL</>
 <MEMBER>MXWKS</>
 <MEMBER>PTR</>
 <MEMBER>TXT</>
 <MEMBER>UINFO</>
 <MEMBER>WKS</>
</SIMPLELIST>
</PARA><PARA>

FIXME! FILL DETAILS! (About the return values)

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>ndbm</></TERM><LISTITEM><PARA>

The <OPTION>-f</>-option defines the base path of the files, and the NDBM
appends ".pag" and ".dir" to each file.

</PARA><PARA>

The newer DBM as created at (I think) BSD 4.2.
This is two-file database with API utilizing nonglobal API, that is,
multiple databases can be open simultaneously.
This appends .dir and .pag to the supplied name!

</PARA><PARA>

Limitation: The length of <EMPHASIS>key</> plus the length of <EMPHASIS>data</>
must not exceed 1024 bytes.
With certain kinds of alias databases this may be too low limit!

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>dbm</></TERM><LISTITEM><PARA>

The <OPTION>-f</>-option defines the base path of the files, and the DBM
appends ".pag" and ".dir" to each file.

</PARA><PARA>

The old ATT DBM library with even worse limitations than <OPTION>ndbm</> has.
Avoid if you can.  (ZMailer can manage with this also, each lookup is done
by opening the DB, and closing immediately afterwards.)

</PARA><PARA>

Some versions of ATT DBM <EMPHASIS>did not</> contain externally callable
<FUNCTION>close</>() function!  ZMailer propably won't work at such a system
anyway...

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>gdbm</></TERM><LISTITEM><PARA>

The <OPTION>-f</>-option defines the path of the database file,
the GDBM does not append anything to the name.

</PARA><PARA>

The GNU implementation of the new DBM library. 
Note: GDBM uses one file, which is named exactly as you parametrize it.
This is unlike NDBM, which appends .dir and .pag to the supplied name!

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>yp,<REPLACEABLE>mapname</></></><LISTITEM><PARA>
The Network Information Service from Sun Microsystems Inc.
(Later renamed to be NIS, the still newer NIS+ is not supported).

</PARA><PARA>

The <OPTION><REPLACEABLE>mapname</></> "subtype" passes knowledge
about which YP-map the query is to be done from.

</PARA><PARA>

The <OPTION>-f</>-option is used to pass the <EMPHASIS>YP-domain</>
information to the interface.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>btree</></TERM><LISTITEM><PARA>

SleepyCat DB 1.x, 2.x, 3.x or 4.x B-Tree database

</PARA><PARA>

The <OPTION>-f</>-option defines the path of the database file,
the SleepyCat DB does not append anything to the name.
(This is true with versions 1.x, 2.x, 3.x, and 4.x.)

</PARA><PARA>

The <OPTION>-C</>-option defines SleepyCat DB environment configuration
file, which can be used to define advanced features, mainly
<EMPHASIS>Concurrent Data Store</> function.
<SCREEN>
 FIXME! FIXME! config file!

$ cat /opt/mail/db/sleepyenv.conf 
#
# SleepyCat DB 3/4 environment settings
#

envhome  = /opt/mail/db
#tmpdir = ...
envmode  = 0600
envflags = CDB, CREATE, RO

</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>bhash</></TERM><LISTITEM><PARA>

SleepyCat DB 1.x, 2.x, 3.x or 4.x HASH database

</PARA><PARA>

The <OPTION>-f</>-option defines the path of the database file,
the SleepyCat DB does not append anything to the name.
(This is true with versions 1.x, 2.x, 3.x, and 4.x.)

</PARA><PARA>

The <OPTION>-C</>-option defines SleepyCat DB environment configuration
file, which can be used to define advanced features, mainly
<EMPHASIS>Concurrent Data Store</> function.
<SCREEN>
 FIXME! FIXME! config file!

$ cat /opt/mail/db/sleepyenv.conf 
#
# SleepyCat DB 3/4 environment settings
#

envhome  = /opt/mail/db
#tmpdir = ...
envmode  = 0600
envflags = CDB, CREATE, RO

</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>selfmatch</></TERM><LISTITEM><PARA>

Given address literal <EMPHASIS>without</> wrapping square brackets,
this "database" decodes the address, and checks if presented IP
address is one used by the system at the moment.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>ldap</></TERM><LISTITEM><PARA>

FIXME! WRITEME!

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-f <REPLACEABLE>file</></></TERM><LISTITEM><PARA>
A file associated with the database, typically the file containing the data,
or the basename of DBM files or something similarly relevant to the database
access routine. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-e <REPLACEABLE>#</></></TERM><LISTITEM><PARA>

The default time-to-live on cached information. 
When the information has been in the cache for this many seconds,
it is discarded. The default is 0.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-s <REPLACEABLE>#</></></TERM><LISTITEM><PARA>

Sets the cache size to the specified number. 
The default is usually 10, depending on the database type. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-b</></TERM><LISTITEM><PARA>

If the key exists in the database, return the key 
as the value. ("Boolean relation")

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-i</></TERM><LISTITEM><PARA>

If the key exists, its value is a byte offset into 
a file named by the subtype for this database. The value then becomes 
the concatenation of the data on the lines following that offset which 
start with whitespace.
</PARA><PARA>

This was used for the aliases file back in early 1990, and is usable
only with <OPTION>ordered</>, and <OPTION>unordered</> database types.
</PARA><PARA>

(FIXME! IMPLEMENT?  To think of it, this makes eminently sense also
 for <OPTION>dbm</>, and <OPTION>ndbm</> which have data size limitations.
 But then, SleepyCat DB is recommended for internal databases anyway.)

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-l</></TERM><LISTITEM><PARA>

Map all keys to ASCII lowercase before searching.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-m</></TERM><LISTITEM><PARA>

Check for file content modification before every access.
Reopen the file when a change is detected.
</PARA><PARA>

This option is used when the <COMMAND>router</> should discover
changes to a database underfoot so it need not be restarted to
use new data.
</PARA><PARA>

This is recommended on relations which use unordered, or ordered
datasets (aliases, routes, ...), and especially if the system is
configured to use <FUNCTION>mmap(2)</> facility.
Updating such databases should preferably use <COMMAND>mv</> command
to move a new version of the database in place of the old one.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-n</></TERM><LISTITEM><PARA>

If the key exists in the database and the value is null or list,
return the key as value.
Otherwise return the value retrieved, if any. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-u</></TERM><LISTITEM><PARA>

Map all keys to ASCII uppercase before searching. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-d <REPLACEABLE>[pathalias|pathalias.nodot|longestmatch]</></></TERM><LISTITEM><PARA>

Specifies a search driver that allows searching for structured keys using
special knowledge.
The argument to this option must be a known driver.
</PARA><PARA>
FIXME! WRITEME! WRITE MORE!

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-%</></TERM><LISTITEM><PARA>
We shall do positional parameter substitutions ("%0" thru "%9")
on database lookup result data. [XREF??]

</PARA><PARA>
The <COMMAND>zmailer newdb</> configuration file
<FILENAME>$<VARNAME>MAILVAR</>/dbases.conf</> uses presence of
"%" to signal this aspect of relation wrapper generation.
 [XREF??]

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-:</></TERM><LISTITEM><PARA>
Actually this is <EMPHASIS>ignored</> if present, the
<COMMAND>zmailer newdb</> configuration file
<FILENAME>$<VARNAME>MAILVAR</>/dbases.conf</> uses presence of
":" to signal certain aspects of relation wrapper generation.
 [XREF??]

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

On systems with <LITERAL>USE_MMAP</> the ordered, and unordered
databases are r/o mapped into memory, and for ordered case,
a special line-index is generated for speeding up the binary 
search. (Makes less system calls that way.)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.rest">
<TITLE><FUNCTION>rest</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>rest</>
    <ARG CHOICE=PLAIN><REPLACEABLE>object-reference</></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

Pointer to copied lisp-object of  object-reference's
<LINK LINKEND="zmshref.cdr"><CITETITLE>
<FUNCTION>cdr</></></LINK> operation.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This command is synonymous to the <LINK LINKEND="zmshref.cdr"><CITETITLE>
<FUNCTION>cdr</></></LINK> command (at <XREF LINKEND="zmshref.cdr">).

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.return">
<TITLE><FUNCTION>return</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
 <COMMAND>return <REPLACEABLE>lisp-object</></>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>lisp-object</TERM><LISTITEM><PARA>

The argument lisp-object contains a non ASCII digit character, or is
a complex lisp-object.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>string</TERM><LISTITEM><PARA>

The argument lisp-object contains a non ASCII digit character, and is
a simple string-object.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>statuscode</TERM><LISTITEM><PARA>

The argument lisp-object contains a all ASCII digit characters, and is
a simple string-object.

</PARA><PARA>
See the Notes below about this, too.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>NULL</TERM><LISTITEM><PARA>

Invalid lisp-object.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

The system has a weird dichtomy on returning numeric vs. other results.
</PARA><PARA>

Presume a function call with two different possible results,
failure indication, and successfull (arbitrary) string result:
<SCREEN>
  tmp=$(funcnnn args..) && returns $tmp
  return $tmp  # error code return!
</SCREEN>


</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.returns">
<TITLE><FUNCTION>returns</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
 <COMMAND>returns <REPLACEABLE>lisp-object</></>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>lisp-object</TERM><LISTITEM><PARA>

This one will always return the lisp object without
interpreting possible string value to be numeric return code.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

See notes of "<FUNCTION>return</>" above.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.rfc822">
<TITLE><FUNCTION>rfc822</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>rfc822</>
    <ARG CHOICE=PLAIN><REPLACEABLE>messagefile</></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

status

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This function controls the parsing and processing of the message file
in RFC822/976/2822 format.
It is called by the  <LINK LINKEND="zmshref.process"><CITETITLE>
<FUNCTION>process</></></LINK> function (at <XREF LINKEND="zmshref.process">).
. 

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.rfc822date">
<TITLE><FUNCTION>rfc822date</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>rfc822date</>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Side effect: <LITERAL>stdout</> gets current time string
printed in RFC822/2822 format.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Prints the current time in RFC822/2822 format.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.rfc822syntax">
<TITLE><FUNCTION>rfc822syntax</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>rfc822syntax</>
    <ARG CHOICE=PLAIN><REPLACEABLE>address</></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Given input matches RFC 822/976/2822 for "route-address"
syntax specification.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>1</TERM><LISTITEM><PARA>

Error.  Given input is syntactically somehow invalid.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>64</TERM><LISTITEM><PARA>

Argument count is not exactly 1. (Usage.)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This is a simple interface to the address parser.
If the command line argument is a syntactically valid RFC822/976/2822 address,
this command is silent and returns 0 as status.
If there is a parse error, a verbose error message is printed to
<LITERAL>stdout</> and the function yields a non-zero return status.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.runas">
<TITLE><FUNCTION>runas</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
 <COMMAND>runas</>
   <ARG CHOICE=PLAIN><REPLACEABLE>user</></ARG>
   <ARG CHOICE=PLAIN><REPLACEABLE>function</></ARG>
   <ARG REP=REPEAT><REPLACEABLE>arguments</></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

Any of the values yielded by the executed "function", or:

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Internal evaluation of "function" did yield 0.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>1</TERM><LISTITEM><PARA>

Setting target uid failed.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>64</TERM><LISTITEM><PARA>

Mandatory parameters missing. (Usage.)

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>abort</TERM><LISTITEM><PARA>

Resetting target uid to system uid (root) failed.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Changes the current effective user id of the <EMPHASIS>router</>
process to that given (which may be numeric or an account name),
then runs the specified function with the specified arguments,
then switches the effective user id of the process back (to root). 

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.sender">
<TITLE><FUNCTION>sender</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>sender</>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>1</TERM><LISTITEM><PARA>

Is a sender address.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Is not sender address.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

A boolean function that returns the value of the statement
"executing a header rewriting function and the address 
is a sender address in a message header". 

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.set">
<TITLE><FUNCTION>set</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>set</>
    <GROUP>
      <ARG><OPTION>-a</></ARG>
      <ARG><OPTION>-e</></ARG>
      <ARG><OPTION>-f</></ARG>
      <ARG><OPTION>-h</></ARG>
      <ARG><OPTION>-n</></ARG>
      <ARG><OPTION>-t</></ARG>
      <ARG><OPTION>-u</></ARG>
      <ARG><OPTION>-v</></ARG>
      <ARG><OPTION>-x</></ARG>
      <ARG><OPTION>-L</></ARG>
      <ARG><OPTION>-C</></ARG>
      <ARG><OPTION>-P</></ARG>
      <ARG><OPTION>-S</></ARG>
      <ARG><OPTION>-k</></ARG>
    </GROUP>
    <ARG><OPTION>-</></ARG>
    <ARG><REPLACEABLE>variable</></ARG>
</CMDSYNOPSIS>

Without parameters <FUNCTION>set</> prints variable values.



</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

Pointer to copied structure of <FUNCTION>car</> operation.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>-a</></TERM><LISTITEM><PARA>

Automatically export changed variables.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-e</></TERM><LISTITEM><PARA>

Exit on error exit status of any command.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-f</></TERM><LISTITEM><PARA>

Disable filename generation (no globbing).

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-h</></TERM><LISTITEM><PARA>

Hash program locations.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-n</></TERM><LISTITEM><PARA>

Read commands but do not execute them.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-t</></TERM><LISTITEM><PARA>

Read and execute one command only.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-u</></TERM><LISTITEM><PARA>

Unset variables are error on substitution.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-v</></TERM><LISTITEM><PARA>

Print shell input lines as they are read.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-x</></TERM><LISTITEM><PARA>

Print commands as they are executed.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-L</></TERM><LISTITEM><PARA>

Trace LEXER processing (sslWalker).

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-C</></TERM><LISTITEM><PARA>

Print branch and emit inputs (sslWalker).

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-P</></TERM><LISTITEM><PARA>

Trace execution (sslWalker).

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-S</></TERM><LISTITEM><PARA>

Print input buffers when used (sslWalker). 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-k</></TERM><LISTITEM><PARA>

Not supported option.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>-</></TERM><LISTITEM><PARA>

Do nothing.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.shift">
<TITLE><FUNCTION>shift</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>
<CMDSYNOPSIS>
  <COMMAND>shift</COMMAND>
    <ARG>number</ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Success.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>1</TERM><LISTITEM><PARA>

Error, out of parameters to shift.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Modifies caller's argument vector by shifting left one (or specified number)
of argument(s) in current <LITERAL>ARGV</>.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.sleep">
<TITLE><FUNCTION>sleep</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>sleep</COMMAND>
    <ARG CHOICE=PLAIN><REPLACEABLE>number</></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Did sleep a bit, does not tell is anybody interrupted the sleep.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>64</TERM><LISTITEM><PARA>

Missing mandatory integer argument. (Usage.)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Does not tell if the sleep has been interrupted somehow.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.squirrel">
<TITLE><FUNCTION>squirrel</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>squirrel</>
    <ARG CHOICE=PLAIN>[-]event</ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>



</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>1</TERM><LISTITEM><PARA>

Error.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>-</></TERM><LISTITEM><PARA>

Set flag value to 0.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>(none)</TERM><LISTITEM><PARA>

Set flag value to 1. 

</PARA><PARA>

The events are: 
<ITEMIZEDLIST>
<LISTITEM><PARA>
 <LITERAL>breakin</>
</PARA></LISTITEM>
<LISTITEM><PARA>
 <LITERAL>badheader</>
</PARA></LISTITEM>
<LISTITEM><PARA>
 <LITERAL>illheader</>
</PARA></LISTITEM>
<LISTITEM><PARA>
 <LITERAL>nochannel</>
</PARA></LISTITEM>
<LISTITEM><PARA>
 <LITERAL>nosender</>
</PARA></LISTITEM>
</ITEMIZEDLIST>


</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Sets the kinds of events that cause a message to be copied into
the <FILENAME CLASS=DIRECTORY>$<ENVAR>POSTOFFICE</>/postman/</> directory. 
Whether or not a "<LITERAL>-</>" is necessary for an event depends on 
the current state of the event's flag.

</PARA><PARA>
The usage message will indicate what to do to toggle the event flag:
<SCREEN>
<PROMPT>z# </><USERINPUT>squirrel</>
Usage: squirrel [ breakin | -badheader | illheader | nochannel | nosender ]
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.stability">
<TITLE><FUNCTION>stability</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>stability</>
    <GROUP>
      <ARG><OPTION>on</></ARG>
      <ARG><OPTION>off</></ARG>
    </GROUP>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Did the work successfully.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>64</TERM><LISTITEM><PARA>

Bad parameters. (Usage.)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Determines whether the <EMPHASIS>router</> will process incoming messages
in arrival order (when on), or in random order determined by position in
the router directory.
The <EMPHASIS>router</> will by default do the first queue scan in stable
mode, and subsequent  scans in unstable mode.
The name of this command is the name for a similar characteristic of sorting
algorithms. 

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.test2">
<TITLE>"<FUNCTION>test</>", "<FUNCTION>[</>"</TITLE>

<PARA>
See: "<LINK LINKEND="zmshref.test"><CITETITLE><FUNCTION>[</></></>",
a.k.a. "<LINK LINKEND="zmshref.test"><CITETITLE><FUNCTION>test</></></>"
at <XREF LINKEND="zmshref.test">.

</PARA>

</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID="zmshref.times">
<TITLE><FUNCTION>times</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>times</>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Prints to <LITERAL>stdout</> the spent usermode time for
process itself, and to all of its children.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>1</TERM><LISTITEM><PARA>

Error in <FUNCTION>times</>(2) system call.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>64</TERM><LISTITEM><PARA>

Usage error (no parameters allowed.)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Prints to <LITERAL>stdout</> the spent usermode time for
process itself, and to all of its children.

</PARA><PARA>
Sample output:
<SCREEN>
    12m33s  22m59s
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID=zmshref.trace>
<TITLE><FUNCTION>trace</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>trace</>
    <ARG CHOICE=PLAIN>key1 ... keyN</>
  <COMMAND>untrace</>
    <ARG CHOICE=PLAIN>key1 ... keyN</>
</CMDSYNOPSIS>

Enables tracing of the specified items. The valid keywords 
are listed in the options below. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Successful setting/clearing.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>64</TERM><LISTITEM><PARA>

Parameter name error. (Usage.)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>all</></TERM><LISTITEM><PARA>

Turns on all tracing options.
</PARA><PARA>

You only do this to test the I/O capabilities of your system. 
(<OPTION>rfc822</>, and <OPTION>regexp</> options generate
<EMPHASIS>a lot of output!</>)

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>assign</></TERM><LISTITEM><PARA>

Prints shell variable assignments. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>bind</></TERM><LISTITEM><PARA>

Prints various information from the code that calls the DNS resolver. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>compare</></TERM><LISTITEM><PARA>

Prints <FUNCTION>*sift</> statement pattern-selector comparisons. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>db</></TERM><LISTITEM><PARA>

Prints database lookups, including cache search and update information. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>except</></TERM><LISTITEM><PARA>

Inverts the sense of what is being done; e.g.:
<SCREEN>
  trace all except rfc822 regexp
</SCREEN>
which is (nearly) exquivalent of:
<SCREEN>
  trace all
  untrace rfc822 regexp
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>final</></TERM><LISTITEM><PARA>

Prints the message envelope information after processing each message. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>functions</></TERM><LISTITEM><PARA>

Prints shell function calls and return values,
with nesting indicated by indentation. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>matched</></TERM><LISTITEM><PARA>

Prints <FUNCTION>*sift</> statement pattern-selector matches. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>memory</></TERM><LISTITEM><PARA>

Prints memory allocation information after each message. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>on</></TERM><LISTITEM><PARA>

Same as <OPTION>functions</> -option. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>regexp</></TERM><LISTITEM><PARA>

Prints regular expression matching execution. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>resolv</></TERM><LISTITEM><PARA>

Turns on the <LITERAL>RES_DEBUG</> flag in the <EMPHASIS>BIND</> resolver
library, and prints various information from the code that calls
the DNS resolver. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>rewrite</></TERM><LISTITEM><PARA>

Prints the tokenized addresses sent through the message header address
rewriting functions. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>router</></TERM><LISTITEM><PARA>

Prints the tokenized addresses sent through the <FUNCTION>router</> function. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>sequencer</></TERM><LISTITEM><PARA>

Prints the procedural steps taken during message processing. 

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Authors most common "<FUNCTION>trace</>" incantation has been
wrapped into standard script routine:

<SCREEN>
#|
#|  I kept typing in this trace command so frequently, that eventually
#|  I just had to make for it into a single command... /Matti Aarnio
#|

rtrace () {
        trace all except rfc822 regexp
}
</SCREEN>
 

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID=zmshref.trap>
<TITLE><FUNCTION>trap</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>trap</>
    <ARG REP=REPEAT>
       <ARG><REPLACEABLE>script trap_nro</></ARG>
    </ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Set successfully, or displayed successfully.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

If no parameters are given, <FUNCTION>trap</> prints all known traps.

</PARA><PARA>
In all aspects this is quite alike any bourne-shell "<FUNCTION>trap</>"
function.

</PARA><PARA>
Set, and unset a trap:
<SCREEN>
  trap "db flush aliasesdb ; log flushed aliases" 16
  trap "" 16
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID=zmshref.type>
<TITLE><FUNCTION>type</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>type</>
    <ARG REP=REPEAT><REPLACEABLE>command</></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Always returns this value.
</PARA><PARA>

The <LITERAL>stdout</> gets the report.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

<SCREEN>
<PROMPT>z# </><USERINPUT>type trap</>
trap is a shell builtin
<PROMPT>z# </><USERINPUT>type foobar</>
foobar not found
<PROMPT>z# </><USERINPUT>foobar () {echo foo}</>
<PROMPT>z# </><USERINPUT>type foobar</>
foobar is a shell function
<PROMPT>z# </><USERINPUT>type rfc822</>
rfc822 is a shell builtin
<PROMPT>z# </><USERINPUT>type process</>
process is a shell function
<PROMPT>z# </><USERINPUT>echo $?</>
0
<PROMPT>z# </><USERINPUT>type no-such-thing
no-such-thing not found</>
<PROMPT>z# </><USERINPUT>echo $?</>
0
<PROMPT>z# </><USERINPUT>type</>
<PROMPT>z# </><USERINPUT>echo $?</>
0
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID=zmshref.uid2login>
<TITLE><FUNCTION>uid2login</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>uid2login</>
     <ARG CHOICE=PLAIN>uid</>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Argument count ok, and "<REPLACEABLE>uid</>" begins with a digit.
</PARA><PARA>

The <LITERAL>stdout</> gets the username.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>64</TERM><LISTITEM><PARA>

Parameter error. (Usage.)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Prints the first account name associated with a specified numeric user id,
if any, or "<REPLACEABLE>uid#uid</>" if no account exists with that user id.
It has the same side-effects as the <LINK LINKEND="zmshref.login2uid">
<CITETITLE><FUNCTION>login2uid</></></LINK> function
(at <XREF LINKEND="zmshref.login2uid">).

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID=zmshref.umask>
<TITLE><FUNCTION>umask</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>umask</>
    <ARG>octal-number-mask</>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Successfull printing of the octal value, or setting new umask(2) value.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>64</TERM><LISTITEM><PARA>

Parameter error. (Usage.)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

Without parameters the new default mask is 077, and old is printed.

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID=zmshref.unset>
<TITLE><FUNCTION>unset</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>unset</>
    <ARG REP=REPEAT>variable</>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Had enough parameters, executed something, and possibly
complained something to "<LITERAL>stderr</>".

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>64</TERM><LISTITEM><PARA>

Missing mandatory (at least one) argument. (Usage.)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This throws away named variables from all variable scopes.

<SCREEN>
<PROMPT>z# </><USERINPUT>echo $TERM</>
xterm
<PROMPT>z# </><USERINPUT>unset TERM</>
<PROMPT>z# </><USERINPUT>echo "'$TERM'"</>
''
</SCREEN>

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID=zmshref.untrace>
<TITLE><FUNCTION>untrace</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>


<CMDSYNOPSIS>
  <COMMAND>trace</>
    <ARG CHOICE=PLAIN>key1 ... keyN</>
  <COMMAND>untrace</>
    <ARG CHOICE=PLAIN>key1 ... keyN</>
</CMDSYNOPSIS>

Disables tracing of the specified items.
This is inverse of <LINK LINKEND="zmshref.trace">
<CITETITLE><FUNCTION>trace</></></LINK>
(at <XREF LINKEND="zmshref.trace">).

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

Successfull clearing/setting

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>64</TERM><LISTITEM><PARA>

Parameter name error. (Usage.)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

See the <LINK LINKEND="zmshref.trace">
<CITETITLE><FUNCTION>trace</></></LINK>
function (at <XREF LINKEND="zmshref.trace">) for valid keywords. 

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

See the <LINK LINKEND="zmshref.trace">
<CITETITLE><FUNCTION>trace</></></LINK>
function (at <XREF LINKEND="zmshref.trace">) for valid keywords. 
  

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>


</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID=zmshref.user>
<TITLE><FUNCTION>user</FUNCTION></TITLE>


<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>user</>
    <ARG CHOICE=PLAIN><REPLACEABLE>object-reference</></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

The next-address (3rd) component of and address quad.

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

This is essentially same as:
<SCREEN>
   $(cdr $(cdr $(cdr $addrquad)))
</SCREEN>


</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>

</SECT2>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<SECT2 ID=zmshref.wait>
<TITLE><FUNCTION>wait</FUNCTION></TITLE>

<VARIABLELIST>
<VARLISTENTRY><TERM>Syntax:</TERM><LISTITEM><PARA>

<CMDSYNOPSIS>
  <COMMAND>wait</>
    <ARG><REPLACEABLE>pid</></ARG>
</CMDSYNOPSIS>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Return Values:</TERM><LISTITEM><PARA>

Besides of the return codes of processes being waited,
this can yield:

<VARIABLELIST>
<VARLISTENTRY><TERM>0</TERM><LISTITEM><PARA>

no more processes

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>64</TERM><LISTITEM><PARA>

Bad parameters. (Usage.)

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Options:</TERM><LISTITEM><PARA>

none  

</PARA></LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Notes:</TERM><LISTITEM><PARA>

none

</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>
</SECT2>
</SECT1>

</CHAPTER>
