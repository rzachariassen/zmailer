<APPENDIX ID="zapp.msg-file-format"><?dbhtml filename="zapp-filefmts.html">
<TITLE>Internal File Data Formats</TITLE>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<SECT1 ID=zapp-filefmts>
<TITLE>ZMailer's Files and Formats </TITLE>


<FIGURE PGWIDE=1 FLOAT=1 ID=fig.zappffmt.zmdirs>
  <TITLE ID=figtit.zappffmt.zmdirs>ZMailer's <FILENAME>$<VARNAME>POSTOFFICE</>/</> directories and files</TITLE>
  <MEDIAOBJECT>
    <IMAGEOBJECT>
      <IMAGEDATA FILEREF="zmdirs.&GEXT;" FORMAT="&GEXT;">
    </IMAGEOBJECT>
  </MEDIAOBJECT>
</FIGURE>


</SECT1>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<SECT1 ID=zapp-filefmts-envelope-header-lines>
<TITLE>Envelope Header Lines</TITLE>

<PARA>
As the <COMMAND>router</> picks up message files from a specific directory.
Normally, message file names can be arbitrary valid file names, and indeed
this is convenient when debugging.
However, because the <COMMAND>router</> daemon scans its own current
directory, miscellaneous output from the <EMPHASIS>router</> process
may show up in this directory (e.g. profiling data, or core dumps
(unthinkable as that is)).
Furthermore, it is useful to be able to hide files from
the <COMMAND>router</> scanning (indeed the <COMMAND>router</> may
wish to do so itself).
</PARA>

<PARA>
When the <COMMAND>process</> is scanning for message files, it only
considers file names that have a certain format.
Specifically, the message file name must start with a digit.
This method was chosen to accomodate the message file names, as generated
by the standard submission interface library routines, which will be strings
of digits representing the message file's inode number.
</PARA>

<PARA>
A message file contains three sections: the message envelope, the message
header, and the message body (in that order).
he message body is separated from the previous sections by a blank line.
The message body may be empty, and either of the message envelope or
message header may be empty.
The restriction on the latter situation, is that one of those sections
must contain destination information for the message.
</PARA>

<PARA>
The message envelope and the message header have very similar syntax.
The only difference is that while the message header must adhere to RFC822,
the message envelope header fields are terminated by whitespace (`` '')
instead of a colon (``:'').
The semantics of the two message file sections is quite different, and
will be covered later.
</PARA>

<PARA>
The message envelope headers are used to carry meta-information about
the message.
The goal is to carry transport-envelope  information separate from message
(RFC-822) headers, and body.
At first the message starts with a set of envelope headers
(*-prefix denotes optional):
<SCREEN>
 *external \n
 *rcvdfrom %s (%s) \n
 *bodytype %s \n
 *errormsg \n
 *with %s \n
 *identinfo %s \n

<EMPHASIS>Either:</>
  from &lt;%s&gt; \n
<EMPHASIS>Or:</>
  channel error \n

 *envid %s \n
 *notaryret %s \n

<EMPHASIS>Then for each recipient pairs of:</>
 *todsn [NOTIFY=...] [ORCPT=...] \n
  to &lt;%s&gt; \n

<EMPHASIS>Just before the data starts, a magic entry:</>
  env-end \n
</SCREEN>
Then starts the message RFC-822 headers, and below it, the body.
</PARA>

<PARA>
The header fields recognized by ZMailer in the message envelope are:
<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>bodytype </><EMPHASIS>word</></TERM>
<LISTITEM><PARA>
not used. Compatibility with the <APPLICATION>sendmail</> feature 
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>channel </><EMPHASIS>word</></TERM>
<LISTITEM><PARA>
sets the channel corresponding to the message origin(*),
usually as ``<LITERAL>channel error</>''
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>comment </><EMPHASIS>string</></TERM>
<LISTITEM><PARA>
arbitrary comment
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>env-end</></TERM>
<LISTITEM><PARA>
separator flag-word in between the envelope and the RFC822 headers
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>env-eof</></TERM>
<LISTITEM><PARA>
alias to <OPTION>env-end</>
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>errormsg</></TERM>
<LISTITEM><PARA>
Special internal flag-word telling that the message in question
has been produced by <COMMAND>scheduler</> or <COMMAND>errormail</>,
and is considered an error message.
</PARA><PARA>
This distinction can be used at routing to determine use of different
default route lookup key for recipients in this case.
See file <FILENAME>p-routes.cf</>.
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>envid </><EMPHASIS>xtext</></TERM>
<LISTITEM><PARA>
ESMTP DSN ENVID value
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>external</></TERM>
<LISTITEM><PARA>
A flag-word indicating the external origin of a message
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>from </><EMPHASIS>``address''</></TERM>
<LISTITEM><PARA>
a source address(*)
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>fullname </><EMPHASIS>``phrase''</></TERM>
<LISTITEM><PARA>
sets the full name of the local sender
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>identinfo </><EMPHASIS>``string''</></TERM>
<LISTITEM><PARA>
The SMTP server's ident lookup result, this does not guarantee anything
about the sender though.
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>loginname </><EMPHASIS>``word''</></TERM>
<LISTITEM><PARA>
requests using this mail id for the local sender
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>notaryret </><EMPHASIS>``word''</></TERM>
<LISTITEM><PARA>
ESMTP DSN RET=<EMPHASIS>word</>, either ``<LITERAL>FULL</>'',
or ``<LITERAL>HDRS</>''
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>rcvdfrom </><EMPHASIS>``domain'' (opt comment)</></TERM>
<LISTITEM><PARA>
An optional envelope entry, which sets ``<LITERAL>Received:</>'' header's
``<LITERAL>from</>'' field value.
</PARA>

<PARA>
This should <EMPHASIS>only</> be used on messages that are originated
thru ``trusted'' mechanisms, and especially <EMPHASIS ROLE="BOLD">not</>
be used when the message is originated by some John Doe in the system.
(E.g. this is reserved for <COMMAND>smtpserver</> and friends, not
 for arbitrary users.)
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>to </><EMPHASIS>``address-list''</></TERM>
<LISTITEM><PARA>
Normal recipient address list; usually used in form of listing
one address in angle braces:
<SCREEN>
  to &lt;user@somewhere&gt;
</SCREEN>
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>todsn </><EMPHASIS>``phrase''</></TERM>
<LISTITEM><PARA>
ESMTP DSN recipient parameters.
Note: this must be before the recipient ``<OPTION>to</>'' line for which
this gives the extra parameters.
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>user </><EMPHASIS>``local-part''</></TERM>
<LISTITEM><PARA>
Optional envelope entry telling who the message originating user
was.   The system is extremely suspicuous on this entry, and will
check it against system account database, unless the spool file
owner uid is known to belong to trusted users.
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>verbose </><EMPHASIS>``filename''</></TERM>
<LISTITEM><PARA>
This optional envelope entry tells the router, what filename
the sending client expects the subsystems to use as a feedback
channel for reports concerning the file.
</PARA>

<PARA>
This ``<EMPHASIS>filename</>'' is located into
<FILENAME CLASS="DIRECTORY">$<VARNAME>POSTOFFICE</>/public/</>
directory, and has been preopened by the same uid as has created
the message spool file.
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>via </><EMPHASIS>``word''</></TERM>
<LISTITEM><PARA>
An optional envelope entry that will define ``<LITERAL>Received:</>''
header's optional ``<LITERAL>via</>'' tag telling what physical transport
mechanism was used.
</PARA><PARA>
Usually this entry is <EMPHASIS>not</> used.
(For an exceptions, see <COMMAND>rmail</> and
 <COMMAND>listexpand</> utility.)
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>with </><EMPHASIS>``word''</></TERM>
<LISTITEM><PARA>
An optional envelope entry that will define ``<LITERAL>Received:</>''
header's optional ``<LITERAL>with</>'' tag telling what protocol was used.
</PARA><PARA>
Unlike RFC-822 tells, ZMailer supports only one ``<LITERAL>with</>'' instance.
</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>
</PARA>

<PARA>
The (*)'s beside the descriptions indicate this is a privileged field.
That is, the action will only happen if ZMailer trusts the owner of the
message file (*Note Security: security. XREF ??). 
As with a normal RFC822 header, other fields are allowed (though they
will be ignored), and case is not significant in the field name.
The <COMMAND>router</> will do appropriate checks for the fields that
require it.
</PARA>

<PARA>
With this knowledge, we can now appreciate the minimal message file:
<SCREEN>
  ====================
  to bond
   
  ====================
</SCREEN></PARA>

<PARA>
This will cause an empty message to be sent to <EMPHASIS>bond</>.
A slightly more sophisticated version is:
<SCREEN>
  ====================
  from m
  to bond
  via courier
  env-end
  From: M
  To: Bond
  Subject: do get a receipt, 007!
     
  You are working for the Government, remember?
  ====================
</SCREEN></PARA>

<PARA>
Notice that there is no delimiter between the message envelope and the
message header.  A more sophisticated example in the same vein:
<SCREEN>
  ====================
  from ps/d-ops
  to &lt;007@sis.mod.uk&gt;
  env-end
  From: M &lt;d-ops@sis.mod.uk&gt;
  Sender: Moneypenny &lt;ps/d-ops@sis.mod.uk&gt;
  To: James Bond &lt;007@sis.mod.uk&gt;
  Subject: where are you???!
  Classification: Top Secret
  Priority: Flash
     
  We have another madman on the loose.  Contact "Q" for usual routine.
  ====================
</SCREEN>
</PARA>

<PARA>
If the <EMPHASIS>Classification:</> header is paid attention to in ZMailer,
this requires that the <COMMAND>router</> recognize it in the message
header, and take appropriate action.
In general the <COMMAND>router</> can extract most of the information in
the message header, and make use of it if the information is lacking in
the envelope.
The envelope headers in the above message are superfluous, since the same
information is contained in the message header.
Using the following envelope headers would be exactly equivalent to using
the ones shown above (assuming the local host is <EMPHASIS>sis.mod.uk</>):
<SCREEN>
  ====================
  From Moneypenny &lt;ps/d-ops@sis.mod.uk&gt;
  To James Bond &lt;007@sis.mod.uk&gt;
  ...
  ====================
</SCREEN></PARA>

<PARA>
ZMailer will extract the appropriate address information from whatever the
field values are, as long as they obey the defined syntax (indicated in the
list of recognized envelope fields above).
ZMailer will complain in case of unexpected errors in the envelope headers.
</PARA>

<PARA>
The message body is not interpreted by ZMailer itself.
As far as the <COMMAND>router</> is concerned, it can be arbitrary data.
However, certain <EMPHASIS>Transport Agents</> may require limitations on
the message body data.
For example, the SMTP only deals with ASCII data with a small guaranteed
line length.
</PARA>

</SECT1>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<SECT1 ID=zapp-filefmts-message-control-file>
<TITLE>Message Control File</TITLE>

<PARA>
A message control file is a file created by the <COMMAND>router</> to
contain all the information necessary for delivery of a message submitted
in a corresponding message file.
It is interpreted by the <COMMAND>scheduler</>, which needs to know
at all times which messages are pending to go where, and how.
It is also interpreted by one or more <EMPHASIS>Transport Agents</>,
possibly concurrently, that extract the delivery information relevant
to their purpose.
</PARA>

<PARA>
The concurrency aspect means that the <EMPHASIS>Transport Agents</> must
cooperate on a locking protocol to ensure that delivery to a particular
destination is attempted by only one <EMPHASIS>Transport Agent</> at a time,
and a status protocol to ensure unique success or failure of delivery for
each destination.
There are potentially many ways to implement such protocols, but, in
the spirit of simplicity, ZMailer uses a control file as a form of shared
memory.
Specific locations within each control file are reserved for flags that
indicate a specific state for their associated destination address.
The rest is taken care of by the I/O semantics when multiple processes
update the same file.
</PARA>

<PARA>
Apart from necessary envelope and control information, a control file also
contains the new message header for the message, which contains the header
addresses as rewritten by the <COMMAND>router</>.
Since a message may have several destinations with incompatible address
format requirements, there may be several corresponding groups of message
headers.
This will be illustrated by the sample control file shown in the following
subsection.
</PARA>


<!-- ============================================================= -->

<SECT2 ID=zapp-filefmts-message-control-file-format>
<TITLE>Format</TITLE>

<PARA>
A control file consists of a sequence of fields.
Each field starts at the beginning of a line
(i.e. at byte 0 or after a Newline), and is identified by the appearance of
a specific character in that location.
This id character is normally followed by a byte containing a tag value
(semaphore flag), followed by the field value.
</PARA>

<PARA>
Here is a simple control file produced by a test message, just before it
was removed by the Scheduler:
<SCREEN>
  ====================
  @ 0x00000007
  i 24700
  o 72
  l &lt;88Jan10.003129est.24700@bay.csri.toronto.edu&gt;
  e Rayan Zachariassen &lt;rayan&gt;
  s local - rayan
  r+          local - rayan 2003
  m
  Received: by bay.csri.toronto.edu id 24700; Sun, 10 Jan 88 00:31:29 EST
  From:   Rayan Zachariassen &lt;rayan&gt;
  To:     rayan, rayan@ephemeral
  Subject: a test
  Message-Id: &lt;88Jan10.003129est.24700@bay.csri.toronto.edu&gt;
  Date:   Sun, 10 Jan 88 00:31:24 EST
  
  s local - rayan@bay.csri.toronto.edu
  r+          smtp ephemeral.ai.toronto.edu rayan@ephemeral.ai.toronto.edu 2003
  m
  Received: by bay.csri.toronto.edu id 24700; Sun, 10 Jan 88 00:31:29 EST
  From:   Rayan Zachariassen &lt;rayan@csri.toronto.edu&gt;
  To:     rayan@csri.toronto.edu, rayan@ephemeral.ai.toronto.edu
  Subject: a test
  Message-Id: &lt;88Jan10.003129est.24700@bay.csri.toronto.edu&gt;
  Date:   Sun, 10 Jan 88 00:31:24 EST
  
  ====================
</SCREEN>
</PARA>

<PARA>
The id character values are defined in
the <FILENAME CLASS=HEADERFILE>mail.h</> system header file,
which currently contains:
<SCREEN>
/* These are in order (roughly) what the router writes out. */
#define _CF_FORMAT      '@'     /* What format variant are we ?? */

#define _CF_FORMAT_TA_PID       0x00000001 /* At 'r' or 'X' lines */
#define _CF_FORMAT_DELAY1       0x00000002 /* At 'r' or 'X' lines */
#define _CF_FORMAT_MIMESTRUCT   0x00000004 /* The 'M' block       */
#define _CF_FORMAT_KNOWN_SET (_CF_FORMAT_DELAY1|_CF_FORMAT_TA_PID | \
                              _CF_FORMAT_MIMESTRUCT)

#define _CF_VERBOSE     'v'     /* log file name for verbose log (mail -v) */
#define _CF_MESSAGEID   'i'     /* inode number of file containing message */
#define _CF_BODYOFFSET  'o'     /* byte offset into message file of body */
#define _CF_LOGIDENT    'l'     /* identification string for log entries */
#define _CF_BODYFILE    'b'     /* alternate message file for new body */
#define _CF_ERRORADDR   'e'     /* return address for error messages */
#define _CF_OBSOLETES   'x'     /* message id of message obsoleted by this */
#define _CF_TURNME      'T'     /* trigger scheduler to attempt delivery now */
#define _CF_SENDER      's'     /* sender triple (channel, host, user) */
#define _CF_RECIPIENT   'r'     /* recipient n-tuple, n >= 3 */
#define _CF_DSNRETMODE  'R'     /* DSN message body return control */
#define _CF_XORECIPIENT 'X'     /* one of XOR set of recipient n-tuples */
#define _CF_RCPTNOTARY  'N'     /* DSN parameters for previous recipient */
#define _CF_DSNENVID    'n'     /* DSN 'MAIL FROM&lt;> ENVID=XXXX' data */
#define _CF_MSGHEADERS  'm'     /* message header for preceeding recipients */
#define _CF_MIMESTRUCT  'M'     /* compacted MIME structure data for message */
#define _CF_DIAGNOSTIC  'd'     /* diagnostic message for ctlfile offset */

/* The following characters may appear in the second column after most _CF_* */
#define _CFTAG_NORMAL   ' '     /* what the router sets it to be */
#define _CFTAG_LOCK     '~'     /* that line is being processed, lock it */
#define _CFTAG_OK       '+'     /* positive outcome of processing */
#define _CFTAG_NOTOK    '-'     /* something went wrong */
#define _CFTAG_DEFER    _CFTAG_NORMAL   /* try again later */
</SCREEN>
</PARA>

<PARA>
There is one field per line, except for <CONSTANT>_CF_MSGHEADERS</>,
and <CONSTANT>_CF_MIMESTRUCT</>, which have some special semantics
described below.
</PARA>

<PARA>
The following describes the fields in detail:

<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>@</> <EMPHASIS>hex-encoded-bitflagset</></TERM><LISTITEM><PARA>
This carries a hex-encoded bitflag set which is used by
the <COMMAND>scheduler</>, and <EMPHASIS>Transport Agents</> to detect
if the <COMMAND>router</> produces files with incompatible features to
what the latter programs know.
</PARA><PARA>
This is used to ensure that there stays a capability relation of:
<SCREEN>
  router <= scheduler <= transport-agents
</SCREEN>
</PARA><PARA>
For example:
<SCREEN>
  @ 0x00000007
</SCREEN>
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>v</> <EMPHASIS>relative-file-path</></TERM><LISTITEM><PARA>
Log file name for verbose log (<USERINPUT>mail -v</>):
<SCREEN>
 v ../public/v_some_magic_tmpfile
</SCREEN>
</PARA></LISTITEM></VARLISTENTRY>


<VARLISTENTRY><TERM><OPTION>i</> <EMPHASIS>filename</></TERM><LISTITEM><PARA>
This field identifies the message file corresponding to this control file.
It is the name of the message file in the <EMPHASIS>QUEUE</> directory
(<FILENAME CLASS="DIRECTORY">$<VARNAME>POSTOFFICE</>/queue/</>).
</PARA><PARA>
This is typically the same as the inode number for that file, but need not be.
It is used by <EMPHASIS>Transport Agents</> when copying the message body,
and by the <COMMAND>scheduler</> when unlinking the file after all of
the destination addresses have been processed.
</PARA><PARA>
For example:
<SCREEN>
  i 21456-789
</SCREEN>


<INFORMALFIGURE PGWIDE=0 FLOAT=0 ID=fig.zappffmt.zmsched1>
<!--  <TITLE ID=figtit.zappffmt.zmsched1>The ``<LITERAL>i</>'' reference meaning</TITLE> -->
  <MEDIAOBJECT>
    <IMAGEOBJECT>
      <IMAGEDATA FILEREF="zmsched1.&GEXT;" FORMAT="&GEXT;">
    </IMAGEOBJECT>
  </MEDIAOBJECT>
</INFORMALFIGURE>


</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>o</> <EMPHASIS>decimal-number</></TERM><LISTITEM><PARA>
Specifies the byte offset of the message body in the message file.
It is used by <EMPHASIS>Transport Agents</> in order to copy
the message body quickly, without parsing the message file.
</PARA><PARA>
For example:
<SCREEN>
  o 466
</SCREEN>
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>l</> <EMPHASIS>message-id-string</></TERM><LISTITEM><PARA>
The field value is an uninterpreted string which should prefix all log
messages and accounting records associated with this message.
This value is typically the message id string.
</PARA><PARA>
For example:
<SCREEN>
  l &lt;88Jan6.103158gmt.24694@sis.mod.uk&gt;
</SCREEN>
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>b</> <EMPHASIS>filename</></TERM><LISTITEM><PARA>
Alternate message file for new body.
(<EMPHASIS>Currently not supported!</>)
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>e</> <EMPHASIS>error-address</></TERM><LISTITEM><PARA>
Gives an address to which delivery errors should be sent.
The address must be a RFC822 mailbox.
</PARA><PARA>
For example:
<SCREEN>
  e "Operations Directorate" &lt;d-ops@sis.mod.uk&gt;
</SCREEN>
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>x</> <EMPHASIS>message-id-string</></TERM><LISTITEM><PARA>
Message id of message obsoleted by this.
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>T</></TERM><LISTITEM><PARA>
This is mainly <COMMAND>smtpserver</> created message directing
the <COMMAND>scheduler</> to trigger sending of given queue
(or other parameter) right (resources permitting).
This is mainly superceded by <EMPHASIS>MAILQv2</> ETRN IPC mechanism.
</PARA><PARA>
For example:
<SCREEN>
  T some.specific.domain (trigger originator IP address)
</SCREEN>
</PARA></LISTITEM></VARLISTENTRY>


<VARLISTENTRY><TERM><OPTION>s</> <EMPHASIS>sender-quad</></TERM><LISTITEM><PARA>
This field specifies an originator (sender) address triple, in the
sequence: previous channel, previous host, return address.
It remains the current sender address until the next instance of this field.
</PARA><PARA>
Since there can only be one sender of a message, multiple instances of
the field will correspond to different return address formats as
produced by the <FUNCTION>crossbar</> algorithm in the <COMMAND>router</>.
</PARA><PARA>
For example:
<SCREEN>
  s smtp sis.mod.uk @lab.sis.mod.uk:q@deadly-sun.lab.sis.mod.uk
  s uucp sisops lab.sis.mod.uk!deadly-sun.lab.sis.mod.uk!q
</SCREEN>
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>r</> <EMPHASIS>10-spaces rcpt-quad</></TERM><LISTITEM><PARA>
This field specifies a destination (recipient) address triple, in the
sequence: next channel, next host, address for next host.
Optional information to be passed to the <EMPHASIS>Transport Agent</>
may be placed after the mandatory fields; this currently refers to
the delivery privilege of the destination address.
Since the optional values of this field are only interpreted by the
<EMPHASIS>Transport Agent</>, changes in what the <COMMAND>router</>
writes must be coordinated with the code of the <EMPHASIS>Transport Agents</>
that might interpret this field.
</PARA><PARA>
For recipient processing interlocks, and delay report flags there is
6+4 spaces before the actual recipient address quad.
</PARA><PARA>
For example:
<SCREEN>
  ==123456ABCD....
  r           local - bond 0
  r           uucp uunet sisops!bond -2
</SCREEN>
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>X</></TERM><LISTITEM><PARA>
One of XOR set of recipient 4-tuples.
(<EMPHASIS>Not used so far.</>)
</PARA></LISTITEM></VARLISTENTRY>


<VARLISTENTRY><TERM><OPTION>N</></TERM><LISTITEM><PARA>
DSN parameters for previous recipient.
</PARA><PARA>
For example:
<SCREEN>
  ==123456ABCD....
  r           local - bond 0
  N ORCPT=rfc822;bond NOTIFY=DELAY,FAILURE
</SCREEN>
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>R</></TERM><LISTITEM><PARA>
DSN message body return control flag.
(While this is stored once per every message
</PARA><PARA>
For example:
<SCREEN>
  ==123456ABCD....
  r           local - bond 0
  N ORCPT=rfc822;bond NOTIFY=DELAY,FAILURE
  R HDRS
</SCREEN>
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>n</></TERM><LISTITEM><PARA>
DSN <LITERAL>MAIL FROM&lt;..&gt; ENVID=XXXX</> data.
</PARA><PARA>
For example:
<SCREEN>
  ==123456ABCD....
  r           local - bond 0
  N ORCPT=rfc822;bond NOTIFY=DELAY,FAILURE
  R HDRS
  n XXXX
</SCREEN>
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>m</></TERM><LISTITEM><PARA>
Apart from a message body, a <EMPHASIS>Transport Agent</>
needs the message headers to construct the message it delivers.
These message headers are stored as the value of this field.
</PARA><PARA>
Since message headers obviously can span lines, the syntax for
this field is somewhat different than for the others.
The field id is immediately followed by a newline, which is followed
by a complete set of message headers.
These are terminated (in the usual fashion) by an empty line, which also
terminates this field.
</PARA><PARA>
In the following example, the last line of text is followed by an empty line,
after which another field may start:
<SCREEN>
  m
  From: M
  To: Bond
  Subject: do get a receipt, 007!
  
  s ...
  r ...
</SCREEN>
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>M</></TERM><LISTITEM><PARA>
This is another multi-line structure reserved for latter support of
pre-scanned MIME structure data so that the transport-agents have
easier work ahead of them when planning things like content transformations
during the transport action. (12-Mar-2001)
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>d</></TERM><LISTITEM><PARA>
This field is <EMPHASIS>not</> written by the <COMMAND>router</>.
It is written by the <COMMAND>scheduler</> or <EMPHASIS>Transport Agents</>
to remember errors associated with specific addresses.
The field value has two parts, the first being the byte offset in the control
file of the destination (recipient) address causing the error, and the rest
of the line being an error message.
The <EMPHASIS>Transport Agents</> discover these errors and report them
to the <COMMAND>scheduler</>.
</PARA><PARA>
The <COMMAND>scheduler</> will collect them and report them to
the error return address (if any) after all the destinations have been
processed.
</PARA><PARA>
For example: (FIXME! XREF to detail data ?)
<SCREEN>
  d 878 No such local user: 'bond'.
</SCREEN>
</PARA></LISTITEM></VARLISTENTRY>

</VARIABLELIST>
</PARA>

<PARA>
It should be noted, that in sender and recipient fields the first two field
values (channel and host) cannot contain embedded spaces, but the third
field value (the address) may.
Therefore, in the presence of extra fields, parsing within
<EMPHASIS>Transport Agents</> must be cautious and not assume that
an address does not contain spaces.
</PARA>

<PARA>
As mentioned, the second byte of most fields are used for concurrency
control and status indication.
This tag byte can contain several values that indicate current or previous
activity.
The fields where this is relevant are the destination (recipient) address
and diagnostic fields.
The tag values are defined in the ``mail.h' file mentioned previously, as
follows:
<SCREEN>
  #define _CFTAG_NORMAL ' ' /* what the router sets it to be */
  #define _CFTAG_LOCK   '~' /* that line is being processed, lock it */
  #define _CFTAG_OK     '+' /* positive outcome of processing */
  #define _CFTAG_NOTOK  '-' /* something went wrong */
  #define _CFTAG_DEFER  _CFTAG_NORMAL /* try again later */
</SCREEN>
</PARA>

<PARA>
The extract above is self-explanatory.
</PARA>

<PARA>
A message control file will normally contain a preamble that specifies
information about the associated message file, the message body offset, an
error return address, and a log entry tag.
After this comes a repeated sequence of: sender address field,
recipient address fields, and the message header corresponding
to these recipients.
After as many of these groups as are necessary, any diagnostic fields
will be appended to the end of the control file.
The restrictions on the sequence of addresses and message headers, are
that a sender address field must precede any recipient address field,
and a recipient address field must (immediately) precede any message header
field, and no sender or recipient addresses may follow the last message
header field.
</PARA>

</SECT2>
</SECT1>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<SECT1 ID=zapp-filefmts-database-fmts>
<TITLE>Database File Formats</TITLE>



<!-- ============================================================= -->

<SECT2 ID=zapp-filefmts-database-fmts-dbases.conf>
<TITLE>The <FILENAME>dbases.conf</> file</TITLE>

<PARA>
Sample of <FILENAME>$<VARNAME>MAILVAR</>/db/dbases.conf</> file:
<SCREEN>
#|
#|  This configuration file is used to translate a semi-vague idea
#|  about what database sources (in what forms) are mapped together
#|  under which lookup names, and what format they are, etc..
#|
#|  This is used by  'zmailer newdb'  command to generate all databases
#|  described here, and to produce relevant  .zmsh  scripts for the
#|  router to use things.  The  'zmailer newdb' invocation does not mandate
#|  router restart in case the database definitions have not changed
#|  (reverse is true:  If definitions are added/modified/removed, the router
#|                     MUST be restarted)
#|

#|Fields:
#|     relation-name
#|         dbtype(,subtype)
#|              dbpriv control data (or "-")
#|                  newdb_compile_options (-a for aliases!)
#|                     dbfile (or "-")
#|                         dbflags (or "-") ... (until end of line)
#|
#| The  dbtype  can be "magic" '$DBTYPE', or any other valid database
#| type for the Router.  Somewhat magic treatment (newdb runs) are
#| done when the dbtype is any of: *DBTYPE/dbm/gdbm/ndbm/btree
#|
#| The "dbfile" need not be located underneath of $MAILVAR, as long as
#| it is in system local filesystem (for performance reasons.)  E.g.
#| one can place one of e.g. aliases files to some persons directory.
#|
#| At  dbflags  (until end of the line), characters ':' and '%' have special
#| meaning as their existence generates lookup routines which pass user's
#| optional parameters.  See documentation about 'dblookup'.
#|

#|Example:
#|
#|Security sensitive ones ("dbpriv" must be defined!)
#| aliases         $DBTYPE  0:0:644    -la $MAILVAR/db/aliases        -lm
#| aliases         $DBTYPE  root:0:644 -la $MAILVAR/db/aliases-2      -lm
#| fqdnaliases     $DBTYPE  root:0:644 -la $MAILVAR/db/fqdnaliases    -lm
#| userdb          $DBTYPE  root:0:644 -la $MAILVAR/db/userdb         -lm
#|
#|Security insensitive ones ("dbpriv" need not be defined!)
#| fqdnaliasesldap ldap   -  -   $MAILVAR/db/fqdnalias.ldap -lm -e 2000 -s 9000
#| fullnamemap     $DBTYPE  -    -l  $MAILVAR/db/fullnames    -lm
#| mboxmap         $DBTYPE  -    -l  $MAILSHARE/db/mboxmap    -lm
#| expired         $DBTYPE  -    -l  $MAILVAR/db/expiredaccts -lm
#| iproutesdb      $DBTYPE  -    -l  $MAILVAR/db/iproutes     -lmd longestmatch
#| routesdb        $DBTYPE  -    -l  $MAILVAR/db/routes       -lm%:d pathalias
#| thishost        $DBTYPE  -    -l  $MAILVAR/db/localnames   -lm%d  pathalias
#| thishost        unordered -   -   $MAILVAR/db/localnames   -ld    pathalias
#| thishost        bind,mxlocal - -  -                        -ld    pathalias
#| otherservers    unordered -   -   $MAILVAR/db/otherservers -lmd   pathalias
#| newsgroup       $DBTYPE  -    -l  $MAILVAR/db/active       -lm


aliases         $DBTYPE 0:0:644    -la $MAILVAR/db/aliases      -lm
fqdnaliases     $DBTYPE root:0:644 -la $MAILVAR/db/fqdnaliases  -lm%
userdb          $DBTYPE root:0:644 -la $MAILVAR/db/userdb       -lm

routesdb        $DBTYPE -   -l  $MAILVAR/db/routes      -lm%:d pathalias
thishost        $DBTYPE -   -l  $MAILVAR/db/localnames  -lm%d  pathalias

#| =================================================================
#|    Set of boilerplate tail-keepers, these lookups fail ALWAYS.
#| These are given because if user ever removes any of the relations
#| mentioned above, the generated "RELATIONNAME.zmsh" script won't
#| just magically disappear!
#| =================================================================

aliases         NONE - - - -
expired         NONE - - - -
fqdnaliasesldap NONE - - - -
fqdnaliases     NONE - - - -
fullnamemap     NONE - - - -
iproutesdb      NONE - - - -
newsgroup       NONE - - - -
otherservers    NONE - - - -
routesdb        NONE - - - -
thishost        NONE - - - -
userdb          NONE - - - -

#| NOTE:  mboxmap  MUST NOT exist at all if its secondary-effects
#|        are to be avoided!
</SCREEN>
</PARA>

</SECT2>

<!-- ============================================================= -->

<SECT2 ID=zapp-filefmts-database-fmts-aliases>
<TITLE>Aliases File</TITLE>

<PARA>For relation: <LITERAL>aliases</></PARA>

<PARA>Syntax of this file is simple: blank lines, and comments with ``#''
character at column 1 are ignored, the key is non-white-space string of
characters terminating on double-colon + whitespace
(actually '"quoted string":' is also valid key!), rest of the line
(and possible continuation lines) are data.
</PARA>

<SCREEN>
  postmaster: root
  postoffice: root
  MAILER-DAEMON: root
  mailer:     postmaster
  postmast:   postmaster
  
  proto:  postmaster
  sync:   postmaster
  sys:    postmaster
  daemon: postmaster
  bin:    postmaster
  uucp:   postmaster
  ingress: postmaster
  audit:  postmaster

  autoanswer: "|@MAILBIN@/autoanswer.pl"

  nobody: /dev/null
  no-one: /dev/null
  "no body": /dev/null
  junk-trap: /dev/null

  #test-gw: "|/..."
  #test.gw: "|/..."
</SCREEN>

<PARA>
Doing expansion lists in <APPLICATION>sendmail</>(8) style is not suggested,
although we certainly can do it.
There is a better mechanism in the ZMailer to handle simple feats like
these that <APPLICATION>sendmail</>(8) systems do by placing the file
containing recipient addresses into the directory 
<FILENAME CLASS="DIRECTORY">$<VARNAME>MAILVAR</>/lists/</>.
This directory must have protection of 2775 or stricter, and the listfile
must have protection of 664 or stricter for *-request/owner-*/*-owner
auto-aliases to work. &mdash; but to <APPLICATION>sendmail</> style lists:
<SCREEN>
  listname: "/usr/lib/sendmail -fowner-listname listname-dist"
  owner-listname: root # Well, what would you suggest for a sample ?
  listname-owner: owner-listname
  listname-request: root
  listname-dist: ":include:/dev/null"
</SCREEN>
</PARA>
</SECT2>

<!-- ============================================================= -->

<SECT2 ID=zapp-filefmts-database-fmts-fqdnaliases>
<TITLE>FQDNAliases File</TITLE>
<PARA>This is syntactically alike the <FILENAME>aliases</> database
(the double-colon + whitespace terminate the key), rest of the line
(and possible continuation lines) are data, however it can have some
interesting keys:
<VARIABLELIST>

<VARLISTENTRY><TERM><LITERAL>local@domain:</></TERM><LISTITEM><PARA>
Matches given address, including possible incoming
<LITERAL>local+tag@domain</> versions.
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><LITERAL>@domain:</></TERM><LISTITEM><PARA>
This matches all addresses with given domain.
</PARA><PARA>
The result data may contain ``<LITERAL>%1</>'' which is filled
with <LITERAL>user</>
part of the input address, example:
<SCREEN>
  @domain:  %1@domain2
</SCREEN>
It can thus be used to map e.g. <LITERAL>user@domain1</> to <LITERAL>user@domain2</>.
</PARA></LISTITEM></VARLISTENTRY>

</VARIABLELIST>

The main difference with <APPLICATION>sendmail</>'s virtuser method is
that this is generic <EMPHASIS>alias</> type mapper, e.g. it can result
in multiple addresses going out, or programs be driven, or&hellip;
</PARA>
</SECT2>

<!-- ============================================================= -->

<SECT2 ID=zapp-filefmts-database-fmts-routes>
<TITLE>Routes File</TITLE>

<PARA>For relation: <LITERAL>routesdb</></PARA>

<PARA>
Sampling here the default boilerplate
``<FILENAME>$<VARNAME>MAILVAR</>/db/routes</>'' file:

<SCREEN>
# Routing Configuration File
#
# Entries in this file are checked first by router.cf.
# They have the form:
#    name  channel!next_destination
# A leading . on the name indicates that all subdomains match as well
#
# We have TWO different fallback lookup tags:
#    .:ERROR  for cases where ERROR MESSAGES we generated are being routed
#    .        for general case
#
# This dictomy is due to need to route everything by explicite tables,
# EXCEPT in case of errors when '.' maps to 'error!something'
# ("We know to whom we route, others get error report back.")
#
# To generate runtime BINARY database of this source, issue command:
#   $MAILBIN/newdb $MAILSHARE/db/routes
# or in this directory with usual configuration:
#   ../bin/newdb routes
#

#
#  Sample route statements (and channels):
#
#   .foo  error!cannedmsgfilename
#   #       Canned error message from $MAILSHARE/forms/cannedmsgfilename
#
#   .bar  smtpx!
#   #       Send all traffic destined to any subdomain under this
#   #       suffix via "smtpx" channel to that domain
#
#   .bar  smtp-etrn!
#   .bar  smtp-tls!
#   .bar  smtp-log!
#   .bar  smtp77!
#   .bar  smtp77x!
#   .bar  smtp8!
#   .bar  smtp8x!
#   #       Ditto
#
#   .bar  smtpgw-xyz!
#   #       Drives genericish gateway function kit
#
#   junkdom      bitbucket!
#   myself       local!
#   news.domain  usenet!
#   uunode.dom   uucp!uunode
#
#   # Usual ISP smart-host setup
#   .       smtpx!ISP.smtp.gw
#
#   # Not so usual - fallback to error, except for error messages
#   .:ERROR smtp!
#   .       error!notourcustomer
#
</SCREEN>
</PARA>
</SECT2>

<SECT2 ID=zapp-filefmts-database-fmts-localnames>
<TITLE>Localnames</TITLE>
<PARA>For relation: <LITERAL>thishost</></PARA>

<PARA>FIXME! WRITEME!</PARA>
</SECT2>

<SECT2 ID=zapp-filefmts-database-fmts-otherservers>
<TITLE>Otherservers</TITLE>
<PARA>For relation: <LITERAL>otherservers</></PARA>

<PARA>FIXME! WRITEME!</PARA>
</SECT2>

<SECT2 ID=zapp-filefmts-database-fmts-iproutes>
<TITLE>Iproutes</TITLE>
<PARA>For relation: <LITERAL>iproutesdb</></PARA>

<PARA>FIXME! WRITEME!</PARA>
</SECT2>


<SECT2 ID=zapp-filefmts-database-fmts-fullnames>
<TITLE>Fullnames</TITLE>
<PARA>For relation: <LITERAL>fullnamemap</></PARA>

<PARA>This used to be a <LITERAL>firstname.lastname</> keyed
mapping database yielding login-ids, but these days this is
superceded by ability to have dots in alias keys.
</PARA><PARA>
Example:
<SCREEN>
  firstname.lastname   loginid
</SCREEN>
</PARA>
</SECT2>

<SECT2 ID=zapp-filefmts-database-fmts-userdb>
<TITLE>Userdb</TITLE>
<PARA>For relation: <LITERAL>userdb</></PARA>
<PARA>FIXME! WRITEME!</PARA>
</SECT2>

<SECT2 ID=zapp-filefmts-database-fmts-expiredaccts>
<TITLE>Expiredaccts</TITLE>
<PARA>For relation: <LITERAL>expired</></PARA>
<PARA>FIXME! WRITEME!</PARA>
</SECT2>

<SECT2 ID=zapp-filefmts-database-fmts-newsgroup>
<TITLE>Active (newsgroups)</TITLE>
<PARA>For relation: <LITERAL>newsgroup</></PARA>
<PARA>FIXME! WRITEME!</PARA>
</SECT2>

<SECT2 ID=zapp-filefmts-database-fmts-aliases.ldap>
<TITLE>Aliases.ldap</TITLE>
<PARA>For relation: <LITERAL>aliases</></PARA>
<PARA>FIXME! WRITEME!</PARA>
</SECT2>

<SECT2 ID=zapp-filefmts-database-fmts-fqdnaliases.ldap>
<TITLE>Fqdnaliases.ldap</TITLE>
<PARA>For relation: <LITERAL>fqdnaliasesldap</></PARA>
<PARA>FIXME! WRITEME!</PARA>
</SECT2>

<SECT2 ID=zapp-filefmts-database-fmts-mailbox>
<TITLE>Mailbox File</TITLE>
<PARA>Err... Uh.. What can be said ?  The standard UNIX mailbox ?</PARA>
<PARA>FIXME! Or was this supposed to be the MBOXMAP thing ?</PARA>
</SECT2>


</SECT1>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<SECT1 ID=zapp-filefmts-scheduler-perflog>
<TITLE><COMMAND>Scheduler</> Statistics Log</>

<PARA>
The  statistics log reports condenced performance oriented
information in following format:
<INFORMALTABLE FRAME=NONE PGWIDE=0>
<TGROUP COLS=6 ALIGN=LEFT COLSEP=0 ROWSEP=0>
<COLSPEC ALIGN=LEFT   COLWIDTH=2>
<COLSPEC ALIGN=LEFT   COLWIDTH=2>
<COLSPEC ALIGN=CENTER COLWIDTH=1>
<COLSPEC ALIGN=CENTER COLWIDTH=1>
<COLSPEC ALIGN=LEFT   COLWIDTH=2>
<COLSPEC ALIGN=LEFT   COLWIDTH=6>
<THEAD>
<ROW ROWSEP=1>
 <ENTRY ALIGN=LEFT>timestamp</>
 <ENTRY ALIGN=LEFT>fileid</>
 <ENTRY ALIGN=CENTER>dt1</>
 <ENTRY ALIGN=CENTER>dt2</>
 <ENTRY ALIGN=LEFT>state</>
 <ENTRY ALIGN=LEFT>$channel/$host</>
</ROW>
</THEAD>
<TBODY>
<ROW>
 <ENTRY>812876190</>
 <ENTRY>90401-2</>
 <ENTRY>0</>
 <ENTRY>5</>
 <ENTRY>ok</>
 <ENTRY>usenet/-</>
</ROW>
<ROW>
 <ENTRY>812876228</>
 <ENTRY>90401-1</>
 <ENTRY>0</>
 <ENTRY>7</>
 <ENTRY>ok</>
 <ENTRY>usenet/-</>
</ROW>
<ROW>
 <ENTRY>812876244</>
 <ENTRY>90401-1</>
 <ENTRY>0</>
 <ENTRY>1</>
 <ENTRY>ok</>
 <ENTRY>local/gopher-admin</>
</ROW>
<ROW>
 <ENTRY>812876244</>
 <ENTRY>90401-1</>
 <ENTRY>0</>
 <ENTRY>5</>
 <ENTRY>ok</>
 <ENTRY>smtp/funet.fi</>
</ROW>
<ROW>
 <ENTRY>812876559</>
 <ENTRY>90401-1</>
 <ENTRY>0</>
 <ENTRY>21</>
 <ENTRY>ok</>
 <ENTRY>smtp/utu.fi</>
</ROW>
</TBODY>
</TGROUP>
</INFORMALTABLE>
</PARA>

<PARA>
Where the fields are:

<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>timestamp</></><LISTITEM><PARA>
The original spoolfile <EMPHASIS>ctime</> (creation time) stamp in decimal.
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>fileid</></><LISTITEM><PARA>
Spoolfile name after the router has processed it.
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>dt1</></><LISTITEM><PARA>
The time difference from spoolfile ctime to 
scheduler control file creation by the router.
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>dt2</></><LISTITEM><PARA>
The time difference from scheduler file <EMPHASIS>ctime</> to
the delivery that is logged on.
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>state</></><LISTITEM><PARA>
What happened?  Values: ok, ok2, ok3, error, error2, expiry
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>$channel/$host</></><LISTITEM><PARA>
Where/how it was processed.
</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>
</PARA>

</SECT1>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

<SECT1 ID=zapp-filefmts-syslogged-log-formats>
<TITLE>Syslogged Log Formats</>

<PARA>
At <EMPHASIS>syslog</> facility the system logs also material,
if it has so been configured.
</PARA>

<PARA>
Different subsystems do different logs, they are described below.
</PARA>

<SECT2 ID=zapp-filefmts-syslog-from-smtpserver>
<TITLE><COMMAND>Smtpserver</>'s Syslog Format</TITLE>

<PARA>
The <EMPHASIS>smtpserver</> may log in multiple formats:
<VARIABLELIST>
<VARLISTENTRY>
<TERM>INFO: connection from ...</TERM>
<TERM>WARN: refusing connection from ...</TERM>
<TERM>INFO: accepted id ... into freeze..</TERM>
<TERM>INFO: TASPID accepted from...</TERM>
<LISTITEM><PARA>
where TASPID: A spool-id that is valid throughout message lifetime
in the system, and should be long-term unique, even.  (Per system.)
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY>
<TERM>EMERG: smtpserver policy database problem...</TERM>
<TERM>ERR:  MAILBIN unspecified in zmailer.conf</TERM>
<LISTITEM><PARA></PARA></LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</PARA>

</SECT2>

<SECT2 ID=zapp-filefmts-syslog-from-router>
<TITLE><COMMAND>Router</>'s Syslog Format</TITLE>

<PARA>
The <COMMAND>router</> does <FUNCTION>syslog</>() in following format:
</PARA>

<PARA>
<SYNOPSIS>taspid: from=&lt;addr&gt;, rrelay=smtprelay, size=nnn, nrcpts=nnn, msgid=str, delay=xx, xdelay=xx</SYNOPSIS>
</PARA>

<PARA>
Where:
<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>taspid</></><LISTITEM><PARA>
The TA-SPOOL-ID &mdash; A spool-id that is valid throughout message lifetime
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>from=</></><LISTITEM><PARA>
the envelope source address
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>rrelay=</></><LISTITEM><PARA>
the message ``rcvdfrom'' envelope header reports.
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>size=</></><LISTITEM><PARA>
Total message size in bytes (envelope+headers+body)
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>nrcpts=</></><LISTITEM><PARA>
Number of recipients for this message
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>msgid=</></><LISTITEM><PARA>
The ``Message-ID:'' header content
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>delay=</></><LISTITEM><PARA>
Delay from message arrival to the system to this logging moment
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>xdelay=</></><LISTITEM><PARA>
Delay during processing &mdash; tells how much time was spent to
process the message.
</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>
</PARA>

</SECT2>

<SECT2 ID=zaapp-filefmts-syslog-from-transport-agents>
<TITLE>Transport Agent's Syslog Format</TITLE>

<PARA>
The transport agents log in following format:
</PARA>

<PARA>
<SYNOPSIS>taspid: to=&lt;addr&gt;, delay=dd, xdelay=xx, mailer=mm, relay=rr (wtt), stat=%s msg</SYNOPSIS>
</PARA>

<PARA>
Here the fields are:
<VARIABLELIST>
<VARLISTENTRY><TERM><OPTION>taspid</></><LISTITEM><PARA>
The ta-spool-id &mdash; A spool-id that is valid throughout message lifetime
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>to=</></><LISTITEM><PARA>
Destination address in whatever form the transport agent uses.
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>delay=</></><LISTITEM><PARA>
Delay from message arrival to the system to this logging moment
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>xdelay=</></><LISTITEM><PARA>
Delay during this processing attempt &mdash; tells how much time <EMPHASIS>this</>
time was spent to process the message.
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>mailer=</></><LISTITEM><PARA>
Tells what ``channel'' was used.
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>relay=</></><LISTITEM><PARA>
Reports on which host the message is relayed thru (``wtthost''), and for
SMTP, also (in parenthesis) what was the relay's IP address.
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM><OPTION>stat=</></><LISTITEM><PARA>
What status was achieved: ok*, delayed, failed, ...
<EMPHASIS ROLE=BOLD>CHECK!</>
</PARA></LISTITEM></VARLISTENTRY>

<VARLISTENTRY><TERM>msg</><LISTITEM><PARA>
Arbitrary text line from whatever system is out there.
</PARA></LISTITEM></VARLISTENTRY>
</VARIABLELIST>
</PARA>

</SECT2>
</SECT1>


</APPENDIX>
