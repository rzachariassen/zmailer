/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.iterate.conf,v 5.9 2003/06/04 00:14:41 hardaker Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "mta.h"

/** Initialize the mtaGroupTable table by defining its contents and how it's structured */
void
initialize_table_mtaGroupTable(void)
{
    static oid      mtaGroupTable_oid[] = { 1, 3, 6, 1, 2, 1, 28, 2 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /** if your table is read only, it's easiest to change the
        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
    my_handler = netsnmp_create_handler_registration("mtaGroupTable",
                                                     mtaGroupTable_handler,
                                                     mtaGroupTable_oid,
                                                     OID_LENGTH
                                                     (mtaGroupTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_mtaGroupTable");
        return;                 /* Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: applIndex */
                                     ASN_INTEGER,       /* index: mtaGroupIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 2;
    table_info->max_column = 34;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = mtaGroupTable_get_first_data_point;
    iinfo->get_next_data_point = mtaGroupTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = mtaGroupTable_context_convert_function;
    iinfo->free_data_context = mtaGroupTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = mtaGroupTable_loop_free;
    iinfo->free_loop_context_at_end = mtaGroupTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_mtaGroupTable",
                "Registering table mtaGroupTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** Initialize the mtaGroupAssociationTable table by defining its contents and how it's structured */
void
initialize_table_mtaGroupAssociationTable(void)
{
    static oid      mtaGroupAssociationTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 28, 3 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /** if your table is read only, it's easiest to change the
        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
    my_handler =
        netsnmp_create_handler_registration("mtaGroupAssociationTable",
                                            mtaGroupAssociationTable_handler,
                                            mtaGroupAssociationTable_oid,
                                            OID_LENGTH
                                            (mtaGroupAssociationTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_mtaGroupAssociationTable");
        return;                 /* Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: applIndex */
                                     ASN_INTEGER,       /* index: mtaGroupIndex */
                                     ASN_INTEGER,       /* index: mtaGroupAssociationIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 1;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        mtaGroupAssociationTable_get_first_data_point;
    iinfo->get_next_data_point =
        mtaGroupAssociationTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context =
        mtaGroupAssociationTable_context_convert_function;
    iinfo->free_data_context = mtaGroupAssociationTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = mtaGroupAssociationTable_loop_free;
    iinfo->free_loop_context_at_end = mtaGroupAssociationTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_mtaGroupAssociationTable",
                "Registering table mtaGroupAssociationTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** Initialize the mtaTable table by defining its contents and how it's structured */
void
initialize_table_mtaTable(void)
{
    static oid      mtaTable_oid[] = { 1, 3, 6, 1, 2, 1, 28, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /** if your table is read only, it's easiest to change the
        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
    my_handler = netsnmp_create_handler_registration("mtaTable",
                                                     mtaTable_handler,
                                                     mtaTable_oid,
                                                     OID_LENGTH
                                                     (mtaTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR, "malloc failed in initialize_table_mtaTable");
        return;                 /* Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: applIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 12;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = mtaTable_get_first_data_point;
    iinfo->get_next_data_point = mtaTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = mtaTable_context_convert_function;
    iinfo->free_data_context = mtaTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = mtaTable_loop_free;
    iinfo->free_loop_context_at_end = mtaTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_mtaTable",
                "Registering table mtaTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** Initialize the mtaGroupErrorTable table by defining its contents and how it's structured */
void
initialize_table_mtaGroupErrorTable(void)
{
    static oid      mtaGroupErrorTable_oid[] = { 1, 3, 6, 1, 2, 1, 28, 5 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /** if your table is read only, it's easiest to change the
        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
    my_handler = netsnmp_create_handler_registration("mtaGroupErrorTable",
                                                     mtaGroupErrorTable_handler,
                                                     mtaGroupErrorTable_oid,
                                                     OID_LENGTH
                                                     (mtaGroupErrorTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo) {
        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_mtaGroupErrorTable");
        return;                 /* Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: applIndex */
                                     ASN_INTEGER,       /* index: mtaGroupIndex */
                                     ASN_INTEGER,       /* index: mtaStatusCode */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = 1;
    table_info->max_column = 3;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = mtaGroupErrorTable_get_first_data_point;
    iinfo->get_next_data_point = mtaGroupErrorTable_get_next_data_point;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    iinfo->make_data_context = mtaGroupErrorTable_context_convert_function;
    iinfo->free_data_context = mtaGroupErrorTable_data_free;

    /** pick *only* one of these if you use them */
    iinfo->free_loop_context = mtaGroupErrorTable_loop_free;
    iinfo->free_loop_context_at_end = mtaGroupErrorTable_loop_free;
#endif

    /** tie the two structures together */
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_mtaGroupErrorTable",
                "Registering table mtaGroupErrorTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** Initializes the mta module */
void
init_mta(void)
{

  /** here we initialize all the tables we're planning on supporting */
    initialize_table_mtaGroupTable();
    initialize_table_mtaGroupAssociationTable();
    initialize_table_mtaTable();
    initialize_table_mtaGroupErrorTable();
}

/** returns the first data point within the mtaGroupTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later (in your main mtaGroupTable_handler routine) that will provide
    you with the data to return in a given row.  This could be the
    same pointer as what my_loop_context is set to, or something
    different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
mtaGroupTable_get_first_data_point(void **my_loop_context,
                                   void **my_data_context,
                                   netsnmp_variable_list * put_index_data,
                                   netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */ ;
    *my_data_context = /** XXX */ ;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *) /** XXX: applIndex data */ ,
                       /** XXX: length of applIndex data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: mtaGroupIndex data */ ,
                       /** XXX: length of mtaGroupIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as mtaGroupTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later (in your main
   mtaGroupTable_handler routine) and the indexes in put_index_data updated
   again. */
netsnmp_variable_list *
mtaGroupTable_get_next_data_point(void **my_loop_context,
                                  void **my_data_context,
                                  netsnmp_variable_list * put_index_data,
                                  netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */ ;
    *my_data_context = /** XXX */ ;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *) /** XXX: applIndex data */ ,
                       /** XXX: length of applIndex data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: mtaGroupIndex data */ ,
                       /** XXX: length of mtaGroupIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the mtaGroupTable table, if anything else needs to be done */
int
mtaGroupTable_handler(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /** perform anything here that you need to do before each
           request is processed. */

        /** the following extracts the my_data_context pointer set in
           the loop functions above.  You can then use the results to
           help return data for the columns of the mtaGroupTable table in question */
        /** XXX */  =
            ( /** XXX */ *)netsnmp_extract_iterator_context(request);
        if ( /** XXX */  == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /** XXX: no row existed, if you support creation and this is a
               set, start dealing with it here, else continue */
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /** the table_iterator helper should change all GETNEXTs
               into GETs for you automatically, so you don't have to
               worry about the GETNEXT case.  Only GETs and SETs need
               to be dealt with here */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_MTAGROUPRECEIVEDMESSAGES:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPREJECTEDMESSAGES:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPSTOREDMESSAGES:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPTRANSMITTEDMESSAGES:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPRECEIVEDVOLUME:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPSTOREDVOLUME:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPTRANSMITTEDVOLUME:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPRECEIVEDRECIPIENTS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPSTOREDRECIPIENTS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPTRANSMITTEDRECIPIENTS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPOLDESTMESSAGESTORED:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPINBOUNDASSOCIATIONS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPOUTBOUNDASSOCIATIONS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPACCUMULATEDINBOUNDASSOCIATIONS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPACCUMULATEDOUTBOUNDASSOCIATIONS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPLASTINBOUNDACTIVITY:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPLASTOUTBOUNDACTIVITY:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPREJECTEDINBOUNDASSOCIATIONS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPFAILEDOUTBOUNDASSOCIATIONS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPINBOUNDREJECTIONREASON:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPOUTBOUNDCONNECTFAILUREREASON:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPSCHEDULEDRETRY:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPMAILPROTOCOL:
                snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPNAME:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPSUCCESSFULCONVERTEDMESSAGES:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPFAILEDCONVERTEDMESSAGES:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPDESCRIPTION:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPURL:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPCREATIONTIME:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPHIERARCHY:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPOLDESTMESSAGEID:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPLOOPSDETECTED:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPLASTOUTBOUNDASSOCIATIONATTEMPT:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            default:
                        /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in mtaGroupTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
                /** set handling... */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in mtaGroupTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}

/** returns the first data point within the mtaGroupAssociationTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later (in your main mtaGroupAssociationTable_handler routine) that will provide
    you with the data to return in a given row.  This could be the
    same pointer as what my_loop_context is set to, or something
    different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
mtaGroupAssociationTable_get_first_data_point(void **my_loop_context,
                                              void **my_data_context,
                                              netsnmp_variable_list *
                                              put_index_data,
                                              netsnmp_iterator_info
                                              *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */ ;
    *my_data_context = /** XXX */ ;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *) /** XXX: applIndex data */ ,
                       /** XXX: length of applIndex data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: mtaGroupIndex data */ ,
                       /** XXX: length of mtaGroupIndex data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) /** XXX: mtaGroupAssociationIndex data */
                       ,
                       /** XXX: length of mtaGroupAssociationIndex data */
                       );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as mtaGroupAssociationTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later (in your main
   mtaGroupAssociationTable_handler routine) and the indexes in put_index_data updated
   again. */
netsnmp_variable_list *
mtaGroupAssociationTable_get_next_data_point(void **my_loop_context,
                                             void **my_data_context,
                                             netsnmp_variable_list *
                                             put_index_data,
                                             netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */ ;
    *my_data_context = /** XXX */ ;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *) /** XXX: applIndex data */ ,
                       /** XXX: length of applIndex data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: mtaGroupIndex data */ ,
                       /** XXX: length of mtaGroupIndex data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) /** XXX: mtaGroupAssociationIndex data */
                       ,
                       /** XXX: length of mtaGroupAssociationIndex data */
                       );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the mtaGroupAssociationTable table, if anything else needs to be done */
int
mtaGroupAssociationTable_handler(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /** perform anything here that you need to do before each
           request is processed. */

        /** the following extracts the my_data_context pointer set in
           the loop functions above.  You can then use the results to
           help return data for the columns of the mtaGroupAssociationTable table in question */
        /** XXX */  =
            ( /** XXX */ *)netsnmp_extract_iterator_context(request);
        if ( /** XXX */  == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /** XXX: no row existed, if you support creation and this is a
               set, start dealing with it here, else continue */
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /** the table_iterator helper should change all GETNEXTs
               into GETs for you automatically, so you don't have to
               worry about the GETNEXT case.  Only GETs and SETs need
               to be dealt with here */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_MTAGROUPASSOCIATIONINDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            default:
                        /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in mtaGroupAssociationTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
                /** set handling... */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in mtaGroupAssociationTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}

/** returns the first data point within the mtaTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later (in your main mtaTable_handler routine) that will provide
    you with the data to return in a given row.  This could be the
    same pointer as what my_loop_context is set to, or something
    different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
mtaTable_get_first_data_point(void **my_loop_context,
                              void **my_data_context,
                              netsnmp_variable_list * put_index_data,
                              netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */ ;
    *my_data_context = /** XXX */ ;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *) /** XXX: applIndex data */ ,
                       /** XXX: length of applIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as mtaTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later (in your main
   mtaTable_handler routine) and the indexes in put_index_data updated
   again. */
netsnmp_variable_list *
mtaTable_get_next_data_point(void **my_loop_context,
                             void **my_data_context,
                             netsnmp_variable_list * put_index_data,
                             netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */ ;
    *my_data_context = /** XXX */ ;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *) /** XXX: applIndex data */ ,
                       /** XXX: length of applIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the mtaTable table, if anything else needs to be done */
int
mtaTable_handler(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /** perform anything here that you need to do before each
           request is processed. */

        /** the following extracts the my_data_context pointer set in
           the loop functions above.  You can then use the results to
           help return data for the columns of the mtaTable table in question */
        /** XXX */  =
            ( /** XXX */ *)netsnmp_extract_iterator_context(request);
        if ( /** XXX */  == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /** XXX: no row existed, if you support creation and this is a
               set, start dealing with it here, else continue */
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /** the table_iterator helper should change all GETNEXTs
               into GETs for you automatically, so you don't have to
               worry about the GETNEXT case.  Only GETs and SETs need
               to be dealt with here */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_MTARECEIVEDMESSAGES:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTASTOREDMESSAGES:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTATRANSMITTEDMESSAGES:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTARECEIVEDVOLUME:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTASTOREDVOLUME:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTATRANSMITTEDVOLUME:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTARECEIVEDRECIPIENTS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTASTOREDRECIPIENTS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTATRANSMITTEDRECIPIENTS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTASUCCESSFULCONVERTEDMESSAGES:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAFAILEDCONVERTEDMESSAGES:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTALOOPSDETECTED:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            default:
                        /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in mtaTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
                /** set handling... */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in mtaTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}

/** returns the first data point within the mtaGroupErrorTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later (in your main mtaGroupErrorTable_handler routine) that will provide
    you with the data to return in a given row.  This could be the
    same pointer as what my_loop_context is set to, or something
    different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
mtaGroupErrorTable_get_first_data_point(void **my_loop_context,
                                        void **my_data_context,
                                        netsnmp_variable_list *
                                        put_index_data,
                                        netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */ ;
    *my_data_context = /** XXX */ ;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *) /** XXX: applIndex data */ ,
                       /** XXX: length of applIndex data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: mtaGroupIndex data */ ,
                       /** XXX: length of mtaGroupIndex data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: mtaStatusCode data */ ,
                       /** XXX: length of mtaStatusCode data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as mtaGroupErrorTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later (in your main
   mtaGroupErrorTable_handler routine) and the indexes in put_index_data updated
   again. */
netsnmp_variable_list *
mtaGroupErrorTable_get_next_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    *my_loop_context = /** XXX */ ;
    *my_data_context = /** XXX */ ;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *) /** XXX: applIndex data */ ,
                       /** XXX: length of applIndex data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: mtaGroupIndex data */ ,
                       /** XXX: length of mtaGroupIndex data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr, (u_char *) /** XXX: mtaStatusCode data */ ,
                       /** XXX: length of mtaStatusCode data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the mtaGroupErrorTable table, if anything else needs to be done */
int
mtaGroupErrorTable_handler(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /** perform anything here that you need to do before each
           request is processed. */

        /** the following extracts the my_data_context pointer set in
           the loop functions above.  You can then use the results to
           help return data for the columns of the mtaGroupErrorTable table in question */
        /** XXX */  =
            ( /** XXX */ *)netsnmp_extract_iterator_context(request);
        if ( /** XXX */  == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /** XXX: no row existed, if you support creation and this is a
               set, start dealing with it here, else continue */
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /** the table_iterator helper should change all GETNEXTs
               into GETs for you automatically, so you don't have to
               worry about the GETNEXT case.  Only GETs and SETs need
               to be dealt with here */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_MTAGROUPINBOUNDERRORCOUNT:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPINTERNALERRORCOUNT:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            case COLUMN_MTAGROUPOUTBOUNDERRORCOUNT:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) /** XXX: column data */
                                         , /** XXX: column data length */
                                         );
                break;

            default:
                        /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in mtaGroupErrorTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
                /** set handling... */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in mtaGroupErrorTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
