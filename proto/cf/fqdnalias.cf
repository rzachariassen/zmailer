# FQDN-alias override
#
# This is the simple interface to the db/fqdnalias file in classical
# aliasing style.
#
# We check in order following:
#   - address existing (in lower-case) in the  fqdnaliases  database
#   - address domain-part existing (@domain) in the  fqdnaliases  database
#   - address existing (in lower-case) in the MAILVAR/fqlists/ -directory
#     in similar manner to those in  MAILVAR/lists/  at the  aliases.cf
#   - owner-*, *-owner, and *-request -relation of the MAILVAR/fqlists/
#     likewise
#
# We do not support '+'-selectors in similar manner to those that aliases
# processing does!
#

# FQDN-aliases initializations
#
# Relations: fqdnalias

provide fqdnaliasdb

#
#  FQDN-aliases, in autoconfigured dbase type
#

if [ -f $MAILVAR/db/fqdnaliases ]; then
	# Need to be updated at boot ?
	if [ ! -f $MAILVAR/db/fqdnaliases$DBEXTtest -o \
	     $MAILVAR/db/fqdnaliases -nt $MAILVAR/db/fqdnaliases$DBEXTtest ]; then
		# Yes, so update!
		$MAILBIN/zmailer newfqdnaliases
	fi
	relation -lmt $DBTYPE -f $MAILVAR/db/fqdnaliases$DBEXT fqdnaliases
else
	fqdnaliases () { return 1 }
fi

require fqdnaliasdb
provide fqdnalias

fqdn_neighbour (domain, address, A) {
	# "domain" is dummy..
	local lcaddress l a priv nattr user athost
	local plustail

	# It may not be a "sender" address!

	case "$(get $A type)" in
	sender)	return 1
		;;
	esac

	lcaddress="$(recase -l "$address")"
	plustail=""

	tsift "$lcaddress" in
	(.+)@(.+)
		user="\1"
		athost="@\2"
		break
		;;
	.*
		return 1 # Not in  uu@hh  form!
		;;
	tfist

	# For a recipient address we may do a FQDN-aliasing
	# We are better NOT to have aliasing loops here, though
	# we do expansion recursion pruning by falling thru to
	# normal target address locality testing, and such...

	# Already expanded ?  If yes, go away!
	$(expansions "$lcaddress") && return 1

	#   Yes, add to the expansions.  Success ?
	#     Yes, Any success with filepriv from the alias db ?
	#       Yes, generate new privilege attribute for it. Success ?
	#         Yes, do the expansion! (echo .. | listexpand ...)
	#
	if a="$(fqdnaliases "$lcaddress")" ; then
		db add expansions "$lcaddress" fqdnaliases
		priv=$(filepriv -M 644 $MAILVAR/db/fqdnaliases$DBEXTtest \
				$(db owner fqdnaliases)) &&
		nattr=$(newattribute $A privilege $priv) &&
		return $(echo "$a" |					\
			 listaddresses	-c "$a fqdn alias expansion" 	\
					-e root			 |	\
			 maprrouter $nattr "fqdnalias" "$address"	\
				"$plustail" "$athost")
	fi

	# Didn't match,

	# Plusfull usernames ??

	ssift "$user" in
	([^+]+)\+(.*)
	    local u2 pl2
	    u2="\1"
	    pl2="+\2"
	    if a="$(fqdnaliases "$u2$athost")" ; then
		db add expansions "$lcaddress" fqdnaliases
		priv=$(filepriv -M 644 $MAILVAR/db/fqdnaliases$DBEXTtest \
				$(db owner fqdnaliases)) &&
		nattr=$(newattribute $A privilege $priv) &&
		return $(echo "$a" |					\
			 listaddresses	-c "$a fqdn+ alias expansion" 	\
					-e root			 |	\
			 maprrouter $nattr "fqdnalias" "$address"	\
				"$pl2" "$athost")

	    fi
	    ;;
	tfiss

	# Didn't match,


	# We may also match for:  "@domain.name"

	# Already expanded ?  If yes, go away!
	$(expansions "$athost") && return 1

	#   Yes, add to the expansions.  Success ?
	#     Yes, Any success with filepriv from the alias db ?
	#       Yes, generate new privilege attribute for it. Success ?
	#         Yes, do the expansion! (echo .. | listexpand ...)
	#
	if a="$(fqdnaliases "$athost")" ; then
		db add expansions "$athost" fqdnaliases
		priv=$(filepriv -M 644 $MAILVAR/db/fqdnaliases \
				$(db owner fqdnaliases)) &&
		nattr=$(newattribute $A privilege $priv) &&
		return $(echo "$a" |				   \
			 listaddresses	-c "$a fqdn alias expansion" 	\
					-e root			 |	\
			 maprrouter $nattr "fqdnalias" "$address"	\
				"$plustail" "$athost")
	fi


# TODO: *@any.domain  which maps  somebody@any.domain via
#	replacement pattern(s): %s@other.domain or other.uucp!%s, or ..
#	to:  somebody@other.domain, or other.uucp!somebody
# Problem: Supporting ONE target replacement is easy, supporting more
#          will need major coding work at ``listexpand'' [mea]


	priv=$(get $A privilege)

	# Do we have a file with that name ?
	a="$MAILVAR/fqlists/$lcaddress"
	l="$preowner$user$postowner$athost"
	nattr=()
	if [ -f "$a" ]; then
		db add expansions "$lcaddress" fqlist
		priv=$(getpriv "644" $priv "$a" maillist)
		nattr=$(newattribute $A privilege $priv sender "$l")
		return $(listexpand	-E "$l" -e "$l" -p $priv	\
					-c "$a file expansion"		\
					"$nattr" "$a" "$user$athost" < "$a")
	fi

	# Ok, if the list (MAILVAR/fqlists/user@host) did exist, we did
	# process it's expansion above.  See if we are looking for *-owner,
	# owner-*, or *-request of same lists.

	ssift "$user" in
	(.+)-owner
		a="$MAILVAR/fqlists/\1$athost"
		[ -f "$a" ] &&
		  return $(rrouter "$(uid2login $(filepriv -M 664 "$a"))" \
				   "$address" $A "" "" "$domain")
		break
		;;
	(.+)-request
		a="$MAILVAR/fqlists/\1$athost"
		[ -f "$a" ] &&
		  return $(rrouter "$(uid2login $(filepriv -M 664 "$a"))" \
				   "$address" $A "" "" "$domain")
		break
		;;
	owner-(.+)
		a="$MAILVAR/fqlists/\1$athost"
		[ -f "$a" ] &&
		  return $(rrouter "$(uid2login $(filepriv -M 664 "$a"))" \
				   "$address" $A "" "" "$domain")
		;;
	tfiss

	return 1
}


mapfqrrouter (attribute, localpart, origaddr, plustail, domain) {
	local shh al

	al=()
	while read address
	do
		case "$address" in
		'')	shh=(((error expansion "$localpart")))
			lappend al $shh
			continue
			;;
		esac

		defer=''
		shh=$(rrouter "$address" "$origaddr" $attribute \
			"$plustail" "$domain")
		[ "$defer" ] &&
		    shh=(((hold "$defer" "$address" $attribute)))
		defer=''
		lappend al $shh
	done
	return $al
}
