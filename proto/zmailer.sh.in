#! /bin/sh
#
# ZMailer startup and maintenance commands
#
#       Copyright 1990 by Rayan S. Zachariassen, all rights reserved.
#       This will be free software, but only when it is finished.
#
#       Some hacking by Matti Aarnio, Copyright 1990-2000
#       Modified for Debian by Christoph Lameter 1997
#

# -------- function definitions first, then main program below ---------

# -----------------------------------------------------------------------
#    newdbprocessor()  -- converts DB configuration to ZMSH scripts
#                         which the router digests at its startup.
#
#|Fields:
#|     relation-name
#|         dbtype(,subtype)
#|              dbpriv_yield_varname
#|                  newdb_compile_options (-a for aliases!)
#|                   dbfile (or "-")
#|                         dbflags (or "-") ...
#|

#|Example:
#|
#| aliases         $DBTYPE  priv -la $MAILVAR/db/aliases        -lm
#| aliases         $DBTYPE  priv -la $MAILVAR/db/aliases-2      -lm
#| fullnamemap     $DBTYPE  -    -l  $MAILVAR/db/fullnames      -lm
#| mboxmap         $DBTYPE  -    -l  $MAILSHARE/db/mboxmap      -lm
#| expired         $DBTYPE  -    -l  $MAILVAR/db/expiredaccts   -lm
#| fqdnaliases     $DBTYPE  priv -la $MAILVAR/db/fqdnaliases    -lm
#| fqdnaliasesldap ldap     -    -   $MAILVAR/db/fqdnalias.ldap -lm -e 2000 -s 9000
#| iproutesdb      $DBTYPE  -    -l  $MAILVAR/db/iproutes       -lm -d longestmatch
#| routesdb        $DBTYPE  -    -l  $MAILVAR/db/routes         -lm
#| thishost        $DBTYPE  -    -l  $MAILVAR/db/localnames     -lm
#| thishost        unordered -   -   $MAILVAR/db/localnames     -l
#| thishost        bind,mxlocal - -  -                          -l
#| otherservers    unordered -   -   $MAILVAR/db/otherservers   -lm -d pathalias
#| newsgroup       $DBTYPE  -    -l  $MAILVAR/db/active         -lm
#| userdb          $DBTYPE  -    -la $MAILVAR/db/userdb         -lm
#
#

newdbprocessor() {
    infn=$1

    relnames=`cat $infn | awk '/^[0-9a-zA-Z]/{print $1;}' | sort | uniq`

    cd $MAILVAR/db

    echoo "( "

    for rel in $relnames
    do
	echoo "${rel}{"
	ofn="$rel.zmsh"
	tfn="/tmp/newdb.$$"
	rnum=1
	> $tfn # Trunc the file
	cat > $ofn <<EOF
# ZMSH init script for relation: $rel

# ---boilerplate head
EOF
	# --- construct each relation, and binding at lookup, generate the db
	cat $infn | ( 
	oo=''
	while read rname rtype rpriv rndbopt rdbfile rdbflags
	do
	    if [ "$rel" = "$rname" ]; then
		rn="${rel}_$rnum"
		rnum=`expr $rnum + 1`

		rdbext=''
		rdbtype=''
		rdbexttst=''
		# Process options into what the newdb really likes to get..
		case "$rndbopt" in
		-)
		    rndbopt=''
		    ;;
		-l)
		    rndbopt='-l'
		    ;;
		-la)
		    rndbopt='-l -a'
		    ;;
		esac
		eval fn=$rdbfile
		echoo "$oo$rn"
		oo=','
		case "$rtype" in
		    *DBTYPE)
			rdbexttst='$DBEXTtest'
			rdbext='$DBEXT'
			rdbtype='$DBTYPE'
			newdb -s $rndbopt -t $DBTYPE $fn
			echoo ":NEW"
			;;
		    ndbm)
			rdbexttst='.pag'
			rdbtype=$rtype
			newdb -s $rndbopt -t ndbm $fn
			echoo ":NEW"
			;;
		    dbm)
			rdbexttst='.pag'
			rdbext=''
			rdbtype=$rtype
			newdb -s $rndbopt -t dbm $fn
			echoo ":NEW"
			;;
		    sdbm)
			rdbexttst='.pag'
			rdbext=''
			rdbtype=$rtype
			newdb -s $rndbopt -t sdbm $fn
			echoo ":NEW"
			;;
		    gdbm)
			rdbexttst='.gdbm'
			rdbext='.gdbm'
			rdbtype=$rtype
			newdb -s $rndbopt -t gdbm $fn
			echoo ":NEW"
			;;
		    btree)
			rdbexttst='.db'
			rdbext='.db'
			rdbtype=$rtype
			newdb -s $rndbopt -t btree $fn
			echoo ":NEW"
			;;
		    bhash)
			rdbexttst='.dbh'
			rdbext='.dbh'
			rdbtype=$rtype
			newdb -s $rndbopt -t btree $fn
			echoo ":NEW"
			;;
		    *)
			rdbexttst='.dat'
			rdbext='.dat'
			
			;;
		    esac
		if [ "$rpriv" = "-" ]; then
		    # ---- No privilege things collected -----
		    cat >> $tfn <<EOF
	if a="\$($rn "\$key")"; then
	    return "\$a"
	fi
EOF
		else
		    # ---- privilege things to collect ----
		    cat >> $tfn <<EOF
	if a="\$($rn "\$key")"; then
	    $rpriv="\$(filepriv -M 644 $rdbfile$rdbexttst \\
			    \$(db owner $rn))" &&
	    return "\$a"
	fi
EOF
		fi
		if [ "$rdbfile" = "-" ]; then
		    cat >> $ofn <<EOF
	relation $rdbflags -t $rtype $rn
EOF
		else
		    cat >> $ofn <<EOF
	relation $rdbflags -t $rtype -f $rdbfile$rdbext $rn
EOF
		fi
	    fi
	done )
	# --- put out tails, and complete..
	cat >> $ofn <<EOF
# boilerplate tail---

$rel(key) {
    local a
EOF
	cat $tfn >> $ofn
	cat >> $ofn <<EOF
    return 1
}
EOF
	rm -f $tfn
	echoo "} "
    done

    echoo ") "
}


# -----------------------------------------------------------------------

checkfreeze () {
    if [ -f $POSTOFFICE/.freeze ]; then
	echo "Sorry, Zmailer is frozen, won't start anything until thawed!"
	exit 0
    fi
}

# -----------------------------------------------------------------------

echoo () {
    echo $eopt "$@$eeol"
}

# -----------------------------------------------------------------------


PATH=/bin:/usr/bin:/sbin:/usr/sbin
if [ -d /usr/ucb ]; then
    PATH=$PATH:/usr/ucb
fi
FLAGS="defaults 50"

ZCONFIG=@ZMAILERCFGFILE@

# Sense how the  echo  works, it is either, or..
# There are POSIX echos, SysV echos, BSD echos...
case "`echo 'foo\c'`" in
    foo)   eopt='' ; eeol='\c' ;;
    *)     eopt='-n' ; eeol='' ;;
esac

. $ZCONFIG || exit 1

#
# We NEED $MAILBIN directory as our first element
# in the $PATH variable; 
#
PATH=$MAILBIN:$PATH

case $POSTOFFICE in
    /*) ;;
    *)  echo "$0: panic!! can't initialize from $ZCONFIG"
            exit 1
            ;;
esac

cd $POSTOFFICE  # So that possible cores are there..

case "$MAILBOX" in
*%*)
    ;; # Format-rule, don't check it being a dir...
*)
    if [ ! -d $MAILBOX ]; then
        echo "$0: panic!!  MAILBOX-variable does not point to a directory!  Verify $ZCONFIG!"
        exit 1
    fi
    ;;
esac

# set up the default arguments
if [ "$1" = "start" -o "$1" = "reload" -o $# = 0 ]; then
        set -$- router scheduler smtpserver
        echoo "Starting Zmailer mail server: "
fi

umask 022

KILL=

for op in $@
do
    shift

    case "$op" in
        stop|kill|nuke|kills|killr)     # print nothing
            ;;
        *)
            echoo "${op} "
            ;;
    esac
    case "$op" in
        router|outer)
            case $KILL in
                -*)
                    if [ -f $POSTOFFICE/.pid.router ]; then
                        router -k > /dev/null
        #           else
        #               echoo "(warning: no .pid.router file) "
                    fi
                    ;;
                *)
		    checkfreeze
                    router $ROUTEROPTIONS
                    ;;
            esac
            ;;
        sched*|ched*)
            case $KILL in
                -*)     kill $KILL -`cat $POSTOFFICE/.pid.scheduler` 2>/dev/null ;;
                *)
			checkfreeze
                        cd $POSTOFFICE/transport
                        # must send signal to scheduler to make it
                        # stop reading the directory for new files
                        PIDFILE=.pid.scheduler
                        if [ -f ../$PIDFILE ]; then
                            PID=`cat ../$PIDFILE`
                            kill -TERM -$PID 2>/dev/null
        #               else
        #                   echoo "(warning: no $PIDFILE file) "
                        fi
                        scheduler $SCHEDULEROPTIONS
                        ;;
            esac
            ;;
        smtp*|mtp*)
            case $KILL in
                -*)     if [ -f $POSTOFFICE/.pid.smtpserver ]; then
                            kill $KILL `cat $POSTOFFICE/.pid.smtpserver` 2>/dev/null
                        elif [ -d $POSTOFFICE/.pid.smtpserver ]; then
                            kill $KILL `cat $POSTOFFICE/.pid.smtpserver/* 2>/dev/null` 2>/dev/null
        #               else
        #                   echo "(warning: no .pid.smtpserver file) "
                        fi
                        ;;
                *)
			checkfreeze
                        cd /
                        if [ -f $MAILSHARE/smtpserver.conf ]; then
                            cd /; smtpserver $SMTPOPTIONS
                        elif [ -d $MAILSHARE/smtpserver.conf ]; then
                            if [ -e $POSTOFFICE/.pid.smtpserver ]; then
                                if [ ! -d $POSTOFFICE/.pid.smtpserver ]; then
                                    echo "CONFIGURATION ERROR!"
                                    echo "Cannot start multiple instances of the smtpserver -"
                                    echo "$POSTOFFICE/.pid.smtpserver is not a directory!"
                                    exit 0
                                fi
                            else
                                mkdir $POSTOFFICE/.pid.smtpserver
                            fi
                            cd $MAILSHARE/smtpserver.conf
                            for serv in *; do
                                SMTPOPTIONS_SAVE=$SMTPOPTIONS
                                if [ -f .$serv ]; then
                                    SMTPOPTIONS=`eval echo \`cat .$serv\``
                                fi
                                smtpserver $SMTPOPTIONS -C $serv -I .pid.smtpserver/$serv
                                SMTPOPTIONS=$SMTPOPTIONS_SAVE
                            done
                        fi
                        ;;
            esac
            ;;
        newdb)
            #
            #  Translate all common flatfile databases to binary db's
            #
	    if [ -r $MAILVAR/db/dbases.conf ]; then
		newdbprocessor $MAILVAR/db/dbases.conf
	    else
		echoo "( "
                if [   -f $MAILVAR/db/routes -a  \
                     ! -f $MAILVAR/db/routes.zmsh ] ; then
                    echoo "routes "
                    newdb -l $MAILVAR/db/routes
                fi
                if [   -f $MAILVAR/db/localnames -a \
                     ! -f $MAILVAR/db/localnames.zmsh ] ; then
                    echoo "localnames "
                    newdb -l $MAILVAR/db/localnames
                fi
                if [ -f $MAILVAR/db/aliases ] ; then
                    echoo "aliases "
                    newaliases -s
                fi
                if [ -f $MAILVAR/db/fqdnaliases ] ; then
                    echoo "fqdnaliases "
                    newfqdnaliases -s
                fi
                echoo ") "
	    fi
            ;;
        newf*)
            newfqdnaliases
            ;;
        newal*)
            newaliases
            ;;
        new-route*)
            newdb -l $MAILVAR/db/routes
            ;;
        new-local*)
            newdb -l $MAILVAR/db/localnames
            ;;
        logsync)
            # Over the years less and less of ZMailer subsystems
            # need poking for logfile restarts.  Initially about
            # all needed them, then smtpserver changed to have the
            # log opened separately for each session, and now [Dec 1999]
            # the router has learned better ways.
            # Still the scheduler is resistant...

            if [ -f $POSTOFFICE/.pid.scheduler ]; then
                pid=`cat $POSTOFFICE/.pid.scheduler`
                kill -1 $pid # SIGHUP the scheduler PROCESS
            fi
            ;;
        logrotate)
            rotate-logs.sh
            ;;
        stop|kill|nuke|kills|killr)
            case $# in
                0)      exec zmailer $op router scheduler smtpserver ;;
            esac
            case $op in
                kill|stop|kills|killr)
                    KILL="-TERM"
                    echoo "Stopping Zmailer services: "
                    ;;
                nuke)
                    KILL="-KILL"
                    echoo "Aborting Zmailer services: "
                    ;;
            esac
            ;;
        resubmit)
            (cd $POSTOFFICE/deferred && mv -i [0-9]* ../router) 2> /dev/null
            ;;
        bootclean)
            rm -f $POSTOFFICE/.pid.* 2> /dev/null
            ;;
        cleanup)
            (cd $POSTOFFICE ;
             find public -type f -mtime +2 -print | xargs rm -f
             find postman -type f -mtime +7 -name '[0-9]*' -print | xargs rm -f
            )
            ;;
        freeze)
            touch $POSTOFFICE/.freeze
            ;;
        unfr*|thaw)
            rm -f $POSTOFFICE/.freeze
            ;;
        *)
            echo "$0: unknown option: $op"
            errflg=1
            ;;
    esac
done

echo

case $errflg in
    1)  echo Usage: $0 "[ router | scheduler | smtpserver | stop | kill | resubmit | bootclean | cleanup | newdb | logrotate | logsync | freeze | thaw ]"
        exit 1
        ;;
esac
exit 0
